1:HL["/_next/static/css/3316adebd22c8ace.css",{"as":"style"}]
0:["khykew7cmut3DKDbdPUpp",[[["",{"children":["blogs",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/3316adebd22c8ace.css","precedence":"next"}]],"$L3"]]]]
4:I{"id":1533,"chunks":["8953:static/chunks/8953-1c724bb7bf4ed0d3.js","295:static/chunks/295-d34a13b7db58c23e.js","4173:static/chunks/4173-6cb56f37ea0ab3fb.js","6779:static/chunks/6779-77c34b4240e4e112.js","3504:static/chunks/3504-a5f6c72caf830771.js","2551:static/chunks/2551-ea3d6a273960c352.js","2720:static/chunks/2720-bf80a470a1037258.js","6221:static/chunks/6221-ea8c826885eba213.js","3722:static/chunks/3722-aed7554ac894b939.js","8769:static/chunks/8769-c670348786be6d66.js","3210:static/chunks/3210-da13dfe3ad3982e8.js","3249:static/chunks/3249-df17f46449a19733.js","8511:static/chunks/8511-7816b968850b63e3.js","3185:static/chunks/app/layout-ab0e0be3fb62f694.js"],"name":"","async":false}
5:I{"id":63146,"chunks":["8953:static/chunks/8953-1c724bb7bf4ed0d3.js","295:static/chunks/295-d34a13b7db58c23e.js","4173:static/chunks/4173-6cb56f37ea0ab3fb.js","6779:static/chunks/6779-77c34b4240e4e112.js","3504:static/chunks/3504-a5f6c72caf830771.js","2551:static/chunks/2551-ea3d6a273960c352.js","2720:static/chunks/2720-bf80a470a1037258.js","6221:static/chunks/6221-ea8c826885eba213.js","3722:static/chunks/3722-aed7554ac894b939.js","8769:static/chunks/8769-c670348786be6d66.js","3210:static/chunks/3210-da13dfe3ad3982e8.js","3249:static/chunks/3249-df17f46449a19733.js","8511:static/chunks/8511-7816b968850b63e3.js","3185:static/chunks/app/layout-ab0e0be3fb62f694.js"],"name":"","async":false}
6:I{"id":41062,"chunks":["2272:static/chunks/webpack-66cf14575948cfbd.js","9065:static/chunks/16714efa-0c77bc03ba8cc278.js","8850:static/chunks/8850-b61b594f840c81c5.js"],"name":"default","async":false}
7:I{"id":93042,"chunks":["2272:static/chunks/webpack-66cf14575948cfbd.js","9065:static/chunks/16714efa-0c77bc03ba8cc278.js","8850:static/chunks/8850-b61b594f840c81c5.js"],"name":"default","async":false}
a:I{"id":12495,"chunks":["8953:static/chunks/8953-1c724bb7bf4ed0d3.js","295:static/chunks/295-d34a13b7db58c23e.js","4173:static/chunks/4173-6cb56f37ea0ab3fb.js","6779:static/chunks/6779-77c34b4240e4e112.js","3504:static/chunks/3504-a5f6c72caf830771.js","2551:static/chunks/2551-ea3d6a273960c352.js","2720:static/chunks/2720-bf80a470a1037258.js","6221:static/chunks/6221-ea8c826885eba213.js","3722:static/chunks/3722-aed7554ac894b939.js","8769:static/chunks/8769-c670348786be6d66.js","3210:static/chunks/3210-da13dfe3ad3982e8.js","3249:static/chunks/3249-df17f46449a19733.js","8511:static/chunks/8511-7816b968850b63e3.js","3185:static/chunks/app/layout-ab0e0be3fb62f694.js"],"name":"","async":false}
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Web Evo - 博客"}],["$","meta","2",{"name":"description","content":"Web Evo全称Web Evolution (网络进化) 是一个现代网络咨询工作室，致力于帮助公司企业和个人实现数字化转型。我们提供设计、架构、开发、运营、产品指导等服务。"}],["$","link","3",{"rel":"manifest","href":"/manifest.json"}],["$","meta","4",{"name":"keywords","content":"Web Evo, Web-Evo, Wev Evolution, WebEvo, web evo, webevo"}],["$","meta","5",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","6",{"name":"bytedance-verification-code","content":"wSvyXEgEi6nNu3eh/eDe"}],["$","meta","7",{"name":"theme-color","content":"#00B0FF"}],["$","meta","8",{"name":"baidu-site-verification","content":"codeva-owAlD1JaUc"}],["$","meta","9",{"name":"msvalidate.01","content":"AB78A0C987D3AEA34B969889512FF33E"}],["$","meta","10",{"name":"google-site-verification","content":"4rS5gjy4-tFOdJO4HvDg0_E4QNcB1D1YeZo29iS4hIY"}],["$","meta","11",{"name":"baidu_union_verify","content":"50312ad0c63983b3fe6c2e2a6e10c386"}],["$","meta","12",{"name":"yandex-verification","content":"00c7edad29c9e045"}],["$","meta","13",{"name":"sogou_site_verification","content":"NxKIJOaIjm"}],["$","meta","14",{"name":"360-site-verification","content":"026caef9c5d27d14371524ad882a339f"}],["$","meta","15",{"name":"shenma-site-verification","content":"ced0831a368866ea173608f4f067519f_1687339017"}],["$","link","16",{"rel":"icon","href":"/favicon.png"}],["$","link","17",{"rel":"apple-touch-icon","href":"/logo192.png"}]]
2:[null,["$","html",null,{"lang":"en","children":["$","body",null,{"children":["$","$L4",null,{"children":[["$","$L5",null,{"children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","blogs","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__"},"styles":[]}],"segment":"blogs"},"styles":[]}]}],[["$","$La",null,{"strategy":"afterInteractive","src":"https://www.googletagmanager.com/gtag/js?id=G-R8ZM6SVZ0K"}],["$","$La",null,{"id":"google-analytics","strategy":"afterInteractive","children":"\n                    window.dataLayer = window.dataLayer || [];\n                    function gtag(){dataLayer.push(arguments);}\n                    gtag('js', new Date());\n                    gtag('config', 'G-R8ZM6SVZ0K');\n                "}]],["$","$La",null,{"id":"microsoft-clarity","dangerouslySetInnerHTML":{"__html":"\n            (function(c,l,a,r,i,t,y){\n        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};\n        t=l.createElement(r);t.async=1;t.src=\"https://www.clarity.ms/tag/\"+i;\n        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);\n    })(window, document, \"clarity\", \"script\", \"b91ge7rn7p\");\n            "}}],["$","$La",null,{"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1031326139722537","crossOrigin":"anonymous","async":true,"strategy":"afterInteractive"}]]}]}]}],null]
8:null
b:I{"id":93138,"chunks":["8418:static/chunks/7694e0e6-db365cbc6ba243c6.js","8953:static/chunks/8953-1c724bb7bf4ed0d3.js","295:static/chunks/295-d34a13b7db58c23e.js","3210:static/chunks/3210-da13dfe3ad3982e8.js","4242:static/chunks/4242-5b9885c544fc2f48.js","6539:static/chunks/6539-8f5e18ddecaf800c.js","5606:static/chunks/app/blogs/page-c77118830c67c46a.js"],"name":"","async":false}
c:T3280,随着大屏幕技术的发展，大屏数字滚动效果在各种应用场景中越来越常见，例如数字展示、统计数据展示等。Vue3 作为一种流行的前端开发框架，提供了强大的工具和便捷的开发方式，非常适合实现大屏数字滚动效果。

本篇博文将介绍如何使用 Vue3 来实现大屏数字滚动效果。在实现过程中，我们可以使用调试工具进行测试和排错，并进行代码优化以提高性能和用户体验。最后，我们将总结本文的内容，并提示读者可以进一步扩展和优化大屏数字滚动效果。

通过本篇博文的学习，读者将能够掌握使用 Vue3 实现大屏数字滚动效果的方法和技巧。无论是在数字展示、统计数据展示还是其他大屏幕应用场景中，都可以借助 Vue3 的强大功能，给用户带来更好的视觉体验。

# 1 技术背景

## 1.1 介绍 Vue3 的基本概念和特点

Vue3 是一种用于构建用户界面的现代 JavaScript 框架。与其前身 Vue.js 相比，Vue3 引入了许多新的功能和改进，使开发者能够更高效地构建可扩展的应用程序。

以下是 Vue3 的一些基本概念和特点：

<mark>「Composition API 组合式 API」</mark>

Vue3 引入了 Composition API，它提供了一种全新的组件组织方式。通过使用 Composition API，您可以将相关逻辑封装在一起，并且可以更好地重用、测试和理解代码。这个特性使得编写复杂组件变得更加简单和灵活。

<mark>「更好的性能」</mark>

Vue3 对底层的响应式系统进行了重写，使其在性能方面有所提升。Vue3 使用 Proxy 来实现响应式数据追踪，减少了不必要的触发和运行时开销，从而提高了整体性能。

<mark>「TypeScript 支持」</mark>

Vue3 原生支持 TypeScript，这意味着您可以在 Vue 项目中使用静态类型检查和自动补全，以提高代码的可靠性和可维护性。

<mark>「更小的包大小」</mark>

Vue3 采用了模块化的设计，可以根据需要按需加载各个功能模块，从而减小了最终打包的文件大小。

## 1.2 解释为什么选择 Vue3 来实现大屏数字滚动效果

在选择使用 Vue3 来实现大屏数字滚动效果时，有几个原因可以考虑：

### 1. Vue3 的响应式系统：

Vue3 的新响应式系统使得跟踪和更新数据变得更加高效。对于大屏数字滚动效果来说，您可以轻松地将数据绑定到组件中，并在数据发生变化时自动更新视图，从而实现数字滚动的效果。

### 2. Composition API 的优势：

Composition API 提供了一种更灵活、可组合的方式来组织代码逻辑。对于大屏数字滚动效果，您可以使用 Composition API 将相关逻辑封装在一起，使其易于管理和重用。

### 3. 生态系统和社区支持：

Vue 拥有庞大的生态系统和活跃的社区支持，这意味着您可以轻松找到各种插件、工具和示例来帮助您实现大屏数字滚动效果。无论是寻求解决方案还是遇到问题，都能够得到广泛的支持。

总之，Vue3 具有强大的响应式系统、灵活的 Composition API 以及丰富的生态系统和社区支持，这些特点使其成为实现大屏数字滚动效果的理想选择。

# 2 准备工作

在开始项目开发之前，需要确定项目的开发环境。以下是一些常用的开发环境工具：

1.  Node.js：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以用于开发服务器端和命令行工具。在 Vue 项目中，我们需要使用 Node.js 来运行一些构建工具和开发服务器。
1.  Vue CLI：Vue CLI 是一个基于 Node.js 的命令行工具，用于快速搭建 Vue 项目的脚手架。它提供了一些常用的开发工具和配置，可以帮助我们快速启动和开发 Vue 项目。

确定了使用 Node.js 和 Vue CLI 作为项目的开发环境后，我们需要进行以下准备工作：

1.  安装 Node.js：首先需要在本地安装 Node.js。可以从 Node.js 官网（https://nodejs.org/）下载适合自己操作系统的安装包，然后按照安装向导进行安装。
1.  安装 Vue CLI：安装完 Node.js 后，可以使用 npm（Node.js 的包管理工具）来安装 Vue CLI。打开命令行工具，运行以下命令进行安装：

```sh
npm install -g @vue/cli
```

这会全局安装 Vue CLI，使得我们可以在命令行中使用`vue`命令。

3.  创建 Vue 项目：安装完 Vue CLI 后，可以使用`vue create`命令来创建一个新的 Vue 项目。在命令行中运行以下命令：

```sh
vue create my-project
```

这会创建一个名为`my-project`的新 Vue 项目。根据提示选择需要的配置选项，等待项目创建完成。

4.  进入项目目录。在命令行中运行以下命令：

```sh
cd my-project
```

5.  安装 Vue3 及相关依赖。在命令行中运行以下命令：

```sh
npm install vue@next
```

这会安装最新版本的 Vue3。

6.  安装其他常用的依赖。根据项目需求，可以安装一些常用的依赖，例如路由器（Vue Router）和状态管理器（Vuex）。在命令行中运行以下命令来安装这些依赖：

```sh
npm install vue-router@next vuex@next
```

至此，我们已经完成了 Vue3 及相关依赖的安装。接下来可以开始进行具体的项目开发了。

# 3 实现步骤

## 3.1 创建Vue组件

在开始实现 Vue 项目之前，我们需要先创建 Vue 组件。以下是创建 Vue 组件的步骤：

### 3.1.1 定义组件的基本结构和样式

首先，我们需要定义组件的基本结构和样式。在 Vue 中，组件通常由一个模板（template）、样式（style）和逻辑（script）组成。

在项目的 src 目录下，创建一个新的文件夹，用于存放组件相关的文件。例如，我们可以创建一个名为"components"的文件夹。

在"components"文件夹中，创建一个新的 Vue 组件文件。例如，我们可以创建一个名为"HelloWorld.vue"的文件。

在"HelloWorld.vue"文件中，定义组件的基本结构和样式。以下是一个示例：

```
<template>
  <div class="hello-world">
    <h1>{{ message }}</h1>
    <button @click="changeMessage">Change Message</button>
  </div>
</template>

<style>
.hello-world {
  background-color: #f0f0f0;
  padding: 20px;
}

h1 {
  color: #333;
}

button {
  background-color: #007bff;
  color: #fff;
  padding: 10px 20px;
  border: none;
  cursor: pointer;
}
</style>
```

在上面的示例中，我们定义了一个包含一个标题和一个按钮的组件。组件的样式使用了一些基本的 CSS 属性。

### 3.1.2 说明组件所需的 props 和 data

接下来，我们需要说明组件所需的 props 和 data。props 是组件的属性，可以从父组件传递数据给子组件。data 是组件的内部数据，用于存储组件的状态。

在"HelloWorld.vue"文件中，我们可以在 script 标签中定义 props 和 data。以下是一个示例：

```
<script>
export default {
  props: {
    message: {
      type: String,
      default: 'Hello, World!'
    }
  },
  data() {
    return {
      // 组件的内部数据
    }
  },
  methods: {
    changeMessage() {
      // 处理按钮点击事件的方法
    }
  }
}
</script>
```

在上面的示例中，我们定义了一个 props，名为"message"，类型为 String，默认值为"Hello, World!"。我们还定义了一个 data 方法，用于返回组件的内部数据。

## 3.2 实现数字滚动效果

在 Vue3 中，可以使用生命周期钩子函数或 Composition API 的 setup 函数来监听数据变化，并编写数字滚动的逻辑代码。

### 3.2.1 使用生命周期钩子函数监听数据变化

在 Vue3 中，可以使用`watch`函数来监听数据的变化。在`mounted`生命周期钩子函数中，可以使用`watch`函数来监听数据的变化，并在数据变化时执行相应的逻辑代码。

```
export default {
  data() {
    return {
      number: 0
    }
  },
  mounted() {
    this.$watch('number', (newValue, oldValue) => {
      // 执行数字滚动的逻辑代码
    })
  }
}
```

### 3.2.2 使用 Composition API 的 setup 函数监听数据变化

在 Vue3 中，可以使用 Composition API 的`watch`函数来监听数据的变化。在`setup`函数中，可以使用`watch`函数来监听数据的变化，并在数据变化时执行相应的逻辑代码。

```
import { ref, watch } from 'vue'

export default {
  setup() {
    const number = ref(0)

    watch(number, (newValue, oldValue) => {
      // 执行数字滚动的逻辑代码
    })

    return {
      number
    }
  }
}
```

在上述代码中，我们使用了`ref`函数来创建一个响应式的数据`number`，并使用`watch`函数来监听`number`的变化。当`number`发生变化时，会执行回调函数中的逻辑代码。

在逻辑代码中，可以根据新旧值之间的差值来实现数字滚动的效果。可以使用定时器或动画库来实现平滑的数字滚动效果。

## 3.3 调试和优化

### 3.3.1 使用调试工具进行测试和排错

在 Vue3 中，可以使用浏览器的开发者工具进行调试和排错。开发者工具提供了一系列的功能，如查看组件的状态、调试代码、查看网络请求等。

**「==Vue Devtools==」**

Vue Devtools 是一个浏览器插件，可以用于调试 Vue 应用程序。它提供了一个界面，可以查看组件的层次结构、组件的状态、事件的触发等。可以通过在浏览器中安装 Vue Devtools 插件来使用它。

**「==Chrome 开发者工具==」**

Chrome 开发者工具是浏览器自带的调试工具，可以用于调试 JavaScript 代码、查看网络请求、查看 DOM 结构等。可以通过右键点击页面，选择“检查”来打开 Chrome 开发者工具。

### 3.3.2 优化代码以提高性能和用户体验

在 Vue3 中，可以通过以下方式来优化代码以提高性能和用户体验。

<mark>「==使用虚拟滚动==」</mark>

如果列表中的数据量很大，可以考虑使用虚拟滚动来提高性能。虚拟滚动只渲染可见区域的内容，而不是渲染整个列表。可以使用第三方库如`vue-virtual-scroller`来实现虚拟滚动。

<mark>「==使用异步组件==」</mark>

如果某个组件的加载时间较长，可以考虑将其设置为异步组件。异步组件会在需要时才进行加载，而不是在页面加载时就加载。可以使用`import`函数来定义异步组件。

<mark>「==使用缓存==」</mark>

如果某个组件的数据在短时间内不会发生变化，可以考虑使用缓存来提高性能。可以使用`computed`属性来缓存计算结果，或者使用`keep-alive`组件来缓存组件的状态。

<mark>「==避免不必要的重新渲染==」</mark>

在 Vue3 中，可以使用`memo`函数来避免不必要的重新渲染。`memo`函数会缓存组件的渲染结果，只有在依赖的数据发生变化时才会重新渲染。

<mark>「==使用懒加载==」</mark>

如果某个资源（如图片、视频）的加载时间较长，可以考虑使用懒加载来提高用户体验。可以使用`Intersection Observer API`来实现懒加载。

以上是一些常见的优化方式，具体的优化策略可以根据具体的应用场景和需求来选择。在优化代码时，可以使用性能分析工具来评估优化效果。

# 4 总结

通过本篇博文的学习，我们了解到 Vue3 作为前端开发框架，在实现大屏数字滚动效果方面具有很大的优势。我们通过创建 Vue 组件、监听数据变化和编写滚动逻辑代码的步骤，成功实现了大屏数字滚动效果。

使用 Vue3 的生命周期钩子函数或 Composition API，我们可以轻松地监听数据变化，并在数据更新时实现流畅的数字滚动效果。通过调试和优化，我们可以提高性能，确保用户获得最佳的视觉体验。

尽管本文只是介绍了基本的实现方法，但读者可以进一步扩展和优化大屏数字滚动效果，根据项目需求添加更多的动画效果或交互功能。Vue3 提供了丰富的工具和功能，为实现更复杂、更个性化的大屏数字滚动效果提供了强大的支持。

无论是数字展示、统计数据展示还是其他大屏幕应用场景，掌握 Vue3 的大屏数字滚动效果将带来更好的用户体验和视觉效果。希望本文对读者在实现大屏数字滚动效果方面提供了一些有价值的指导，并激发了你们的创造力和探索精神。祝愿你们在开发过程中取得出色的成果！
d:T1179,# 1、背景

与后端对接口时，看到有一个`get`请求的接口，它的参数是放在`body`中的

<featur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/v3mqph18.png">
</featur>

`get`「请求参数可以放在」`body`「中？？」

随即问了后端，后端大哥说在postman上是可以的，还给我看了截图

<featur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/bx9g9c34.png">
</featur>

可我传参怎么也调不通！

下面就来探究到底是怎么回事

# 2、能否发送带有body参数的get请求

项目中使用`axios`来进行`http`请求，使用`get`请求传参的基本姿势：

```js
// 参数拼接在url上
axios.get(
  url,
  {
    params: {}
  }
)
```

如果想要将参数放在`body`中，应该怎么做呢？

查看axios[1]的文档并没有看到对应说明，去github上翻看下axios源码[2]看看

在`lib/core/Axios.js`文件中

```js
// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
```

可以看到像`delete`、`get`、`head`、`options`方法，它们只接收两个参数，不过在`config`中有一个`data`

熟悉的`post`请求，它接收的第二个参数`data`就是放在`body`的，然后一起作为给`this.request`作为参数

所以看样子`get`请求应该可以在第二个参数添加`data`属性，它会等同于`post`请求的`data`参数

顺着源码，再看看`lib/adapters/xhr.js`，上面的`this.request`最终会调用这个文件封装的`XMLHttpRequest`

```js
export default isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data

    // 将config.params拼接在url上
    request.open(config.method.toUpperCase(), 
                 buildURL(fullPath, config.params, config.paramsSerializer), true);
    
    // 省略若干代码
    ...

    // Send the request
    request.send(requestData || null);
  });
}
```

最终会将`data`数据发送出去

所以只要我们传递了`data`数据，其实`axios`会将其放在`body`发送出去的

### 2.1 实战

本地起一个`koa`服务，弄一个简单的接口，看看后端能否接收到`get`请求的`body`参数

```js
router.get('/api/json', async (ctx, next) => {
 console.log('get请求获取body： ', ctx.request.body)
  
 ctx.body = ctx.request.body
})

router.post('/api/json', async (ctx, next) => {
 console.log('post请求获取body： ', ctx.request.body)

 ctx.body = ctx.request.body
})
```

为了更好地比较，分别弄了一个`get`和`post`接口

前端调用接口：

```js
const res = await axios.get('/api/json', {
  data: {
    id: 1,
    type: 'GET'
  }
})


const res = await axios.post('/api/json', {
  data: {
    id: 2,
    type: 'POST'
  }
})
console.log('res--> ', res)
```

后端已经接收到请求了，但是`get`请求无法获取到`body`！

结论：

- 前端可以发送带`body`参数的`get`请求，但是后端接收不到

- 这就是接口一直调不通的原因


# 3、这是为何呢？

我们查看`Web Api`标准，在`XMLHttpRequest`中有这么一个说明：

<featur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/2023-11-20_23.30.39.png">
</featur>

「大概意思：如果请求方法是」`GET`「或」`HEAD` 「，那么」`body`「会被忽略的」

所以我们虽然传递了，但是会被浏览器给忽略掉

这也是为什么使用`postman`可以正常请求，但是前端调不通的原因了

因为`postman`并没有遵循`Web Api`的标准，`body`参数没有被忽略

### 3.1 `fetch`是否可以？

https://fetch.spec.whatwg.org/#request-class[3]

答案：也不可以，`fetch`会直接报错

# 总结

1. 结论：浏览器并不支持`get`请求将参数放在`body`中

2. `XMLHTTPRequest`会忽略`body`参数，而`fetch`则会直接报错


### Reference

[1]

https://axios-http.com/docs/intro:https://axios-http.com/docs/intro

[2]

https://github.com/axios/axios/tree/v1.x:https://github.com/axios/axios/tree/v1.x

[3]

https://fetch.spec.whatwg.org/#request-class:https://fetch.spec.whatwg.org/#request-classe:T9ae,很多朋友可能没有想过这个问题：

- 你的网站每天都在正常运行吗？
  
- 服务器有没有偷懒，趁你睡觉的时候它也睡觉了呢？
  

如果不是天天自己去网站看一下，或者是客户反馈，可能有时候连网站挂了，或者是临时掉线了都不知道。

今天在这里给大家推荐一个免费的检测工具，可以在一个固定的频率来监测网站是否正常运行，一旦有情况，即可通过预设的通知方式，告诉我们网站现在出现了什么错误。

**工具链接：**

https://www.210k.cc/go/uptime/

**使用方法：**

进入网站后，先注册一个账号，这里推荐使用QQ邮箱，或者是移动的139邮箱，至于原因嘛，你看到后面就知道了。

注册完成后，需要去邮箱里点击一下验证链接，就可以正常登录了。


<fagtur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/2lsm970k.png">
</fagtur>

<fagtur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/203mmxi9.png">
</fagtur>

下一步：登录帐号

<fagtur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/u5yel3vl.png">
</fagtur>

登录成功后，就进入了帐号后台，默认是dashboard界面：

<fagtur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/stp6x8et.png">
</fagtur>

因为我已经添加了很多个网站，所以可以看到左边的记录，新账号直接添加网站，点击“add new monitor”

<fagtur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/gr27xnws.png">
</fagtur>

填入网站名（可以随便起，给自己看的），网站URL链接

另外还有非常重要的一点，是通知方式，在右侧淡黄色背景那里，一定要填写正确

免费版支持邮件通知，但是我们可以 <mark>巧用微信来接收qq邮箱，这样相当于就可以实时接到网站异常的通知了。</mark>

<fagtur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/wpcxug99.png">
</fagtur>

设置完成后，点击右下角蓝色的“create monitor”就完成了，千万记得通知这里，要打个√

<fagtur>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/bzc1tkbu.png">
</fagtur>

至此，就设置完成了，任何时候网站出现了掉线，我们马上就会在微信上收到邮件通知了。f:T132c,## 背景

在日常开发中，我们可能会经常遇到不同项目需要使用不同版本的 Node.js 的情况。虽然社区已经有了很多成熟的 Node.js 版本管理工具，比如 nvm。但是，这些工具基本都是基于 `shell` 的交互式命令的，用起来可能不太直观便捷：比如在 macOS 平台需要安装支持 arm64 架构的版本的 node，nvm 就没办法通过命令（`nvm ls -remote`）来查看；而在 Windows 平台则需要通过 nvm-windows[1] 来单独安装以获得支持。

今天来分享一个高效的 Node.js 版本可视化管理工具：**nvm-desktop**。

## nvm-desktop 是什么？

nvm-desktop 是一个以可视化界面操作方式管理多个 Node 版本的桌面应用，使用 Electron 构建（支持 Macos 和 Windows 系统）。通过该应用，可以快速安装和使用不同版本的 Node。它完美支持为不同的项目单独设置和切换 Node 版本，不依赖操作系统的任何特定功能和 shell。

nvm-desktop 的功能包括：

- 支持为系统全局和项目单独设置Node引擎版本
  
- 管理Node的命令行工具
  
- 支持英文和简体中文
  
- 支持自定义下载镜像地址 (默认是 https://nodejs.org/dist)
  
- Windows 平台支持自动检查更新
  
- 完整的自动化测试
  

nvm-desktop 支持设置主题，可选项包括：**跟随系统、亮色、暗黑**

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/3pryjuzs.png">
</fagtue>

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/kv5p8fpc.png">
</fagtue>

设置**语言**和**镜像地址**：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/ktuuolzs.png">
</fagtue>

## nvm-desktop 怎么用？

### 下载

首先，在 nvm-desktop 的 Release(释放) 页面[2]下载系统对应的版本：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/lrzu5lvf.png">
</fagtue>

下载完成之后，进行安装。

### **环境配置**

安装完成之后，如果使用的是 Mac 电脑，需要在`~/.bashrc`、 `~/.profile` 或 `~/.zshrc` 文件添加以下内容，以便在登录时自动获取它：

```
export NVMD_DIR="$HOME/.nvmd" export PATH="$NVMD_DIR/bin:$PATH"
```

> 如果电脑系统默认的是 zsh, 可以复制这个命令添加到 `~/.zshrc` 文件中即可。如果电脑使用的是 bash，则复制粘贴到 `~/.bashrc` 文件中去即可。如果有其他安装问题，可以查看官方文档：https://github.com/1111mp/nvm-desktop/blob/main/README-zh_CN.md

### 基本使用

Windows 下则不需要额外的操作，安装好运行之后直接搜索指定的 Node.js 版本点击下载安装即可。

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/ugrn4g9h.png">
</fagtue>

下载的过程中会实时显示下载进度。

安装了新的 Node.js 版本之后，可以在已安装中查看：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/o2shilni.png">
</fagtue>

可以应用或者卸载已经下载好的版本。

可以在终端中查看是否切换成功：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/j36whpvc.png">
</fagtue>

nvm-desktop 还支持为每个项目设置不同的 Node.js 版本，只需从本地添加项目，并设置需要的版本即可：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/y2kz8iev.png">
</fagtue>

这样设置之后，全局的 Node.js 版本和项目的 Node.js 版本互不干扰。

除此之外，点击版本名称可以查看该版本的更新日志，点击右上角的“远程刷新”按钮可以获取最新的 Node.js 版本：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/wwz282m8.png">
</fagtue>

支持搜索 Node.js 版本、 V8 版本、NPM 版本，支持按发布时间排序，对不同版本进行筛选：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/qw00wkap.png">
</fagtue>

### 便捷访问

在 Mac 上，支持在顶部菜单栏便捷修改 Node.js 版本：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/5eazgh6b.png">
</fagtue>

在 Windows 上，支持在右下角菜单便捷修改 Node.js 版本：

<fagtue>
    <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/afl76vmh.png">
</fagtue>

## 小结

**nv**m-desktop 简直是懒人的福音，再也不用写命令去切换 Node.js 版本了！

**Github**：https://github.com/1111mp/nvm-desktop

[1]nvm-windows： *https://github.com/coreybutler/nvm-windows*

[2]Release(释放) 页面： *https://github.com/1111mp/nvm-desktop/releases*10:Te3b,## 背景

最近我的朋友去面某大厂前端岗位，被问到这么一个问题：**vue 中怎么做到输入法输入拼音时不触发 @input 事件呢？**

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/ncq6afu8.png">
</figure>

以前还真没留意过这件事情，毕竟大部分时间用 Vue 就是单纯地用来开发项目，哪会去关注他的一些细节呢？不过既然被问到了，那就趁机了解一下，也没坏处~

## 原生 input 事件

我们可以先抛开 Vue，先来看看原生的 input 事件，他是怎么的一个表现

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/640.png">
</figure>

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/640.gif">
</figure>

有人说用防抖就能解决？但是防抖是解决不了这种情况的，防抖是减少触发频率的，而最终该触发啥还是得触发啥事件，不信我可以加一个防抖试试~

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/e01h2u59.png">
</figure>

用户在输入拼音的过程中停顿了一下，拼音照样会被打印出来

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/641.gif">
</figure>

## Vue的@input事件

我们再来看看 Vue 的 @input 事件，看看表现是如何的

```
<Input @input="handleChange" />
```

```
const handleChange = (e: any) => {
  console.log(e.target.value)
};
```

可以看到 @input 事件跟原生的 input 事件不同，@input 在输入拼音的时候并不会触发，而是最后得出输入法结果时才会去触发

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/642.gif">
</figure>

## 咋做到的？

那么 Vue 到底是咋做到的呢？我们可以去 Vue 的源码中探寻，可以看到 Vue 内部是用了两个方法去处理

-   compositionstart
-   compositionend

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/tunzcjuk.png">
</figure>

我们可以去 MDN 上查查这两个方法到底是用来干啥的~可以看到你在输入需要合成的字符串时，会触发这两个回调函数。而我们输入法输入拼音时就是属于输入合成字符串的情况~

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/yngkw9zc.png">
</figure>

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/h6jye1xx.png">
</figure>

所以我们也可以利用这两个事件，去模拟实现一下 @input 的效果~

```
const input = document.getElementById('input');
input.addEventListener('compositionstart', () => {
  console.log('合成开始');
});
input.addEventListener('compositionend', () => {
  console.log('合成结束');
});
input.oninput = (e) => {
  // 模拟请求
  console.log('发起请求', e.target.value);
};
```

可以看到，当你输入法开始输入时，会触发`compositionstart`，当结束时会触发`compositionend`

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/643.gif">
</figure>

所以我们只需要维护一个变量，去记录当前是否属于输入合成字符串期间，并且把这个变量当成 input 触发的条件即可~

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/ia8ncnva.png">
</figure>

这样就能达到我们想要的效果啦~

<figure>
  <img width="100%" src="https://developers-center.oss-cn-beijing.aliyuncs.com/644.gif">
</figure>


11:T7c2,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_javascript_frameworks_-8-qpc.svg)

## 问题描述

在使用`input`标签的时候，如果设置`type="number"`，那么`maxlength`属性就会失效，无论设置多少位数，都可以输入。

## 解决方案

在`input`标签上添加`oninput`事件，然后在事件中判断输入的值是否超过了`maxlength`的值，如果超过了，就截取前面的值。

## Html中的实现

```
<input type="number" maxlength="3" oninput="checkLength(this)" />
<script>
  function checkLength(obj) {
    if (obj.value.length > obj.maxLength) {
      obj.value = obj.value.slice(0, obj.maxLength);
    }
  }
</script>
```
## Vue中的实现

```
<template>
  <div>
    <input type="number" maxlength="3" @input="checkLength" />
  </div>
</template>
<script>
export default {
  methods: {
    checkLength(e) {
      if (e.target.value.length > e.target.maxLength) {
        e.target.value = e.target.value.slice(0, e.target.maxLength);
      }
    },
  },
}
</script>
```


## React中的实现

```
import React from 'react';
export default function App() {
  const checkLength = (obj) => {
    if (obj.value.length > obj.maxLength) {
      obj.value = obj.value.slice(0, obj.maxLength);
    }
  };
  return (
    <div>
      <input type="number" maxLength="3" onInput={checkLength} />
    </div>
  );
}
```

## Angular中的实现

```
import { Component } from '@angular/core';
@Component({
  selector: 'app-root',
  template: `<input type="number" maxlength="3" (input)="checkLength($event)" />`,
})
export class AppComponent {
  checkLength(obj) {
    if (obj.value.length > obj.maxLength) {
      obj.value = obj.value.slice(0, obj.maxLength);
    }
  }
}
```

## Svelte中的实现

```
<script>
  const checkLength = (obj) => {
    if (obj.value.length > obj.maxLength) {
      obj.value = obj.value.slice(0, obj.maxLength);
    }
  };
</script>
<input type="number" maxlength="3" on:input={checkLength} />
```12:T6f6,

![](http://developers-center.oss-cn-beijing.aliyuncs.com/axios-http.com_1920-1080.png)

## POST的几种提交方式

* application/json

> 这个是我的项目中最常用的一种，我觉得这种格式的好处是抓包的时候非常直观，能够很清楚的看到data的结构。
axios默认Content-type是采用application/json;charset=UTF-8，无需设置直接把对象传进去即可。贼方便。

* application/x-www-form-urlencoded

> ajax 中， contentType都是默认的值：application/x-www-form-urlencoded
特点是提交的数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 会进行了 URL 转码。

* multipart/form-data

> 这也是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，就要让 form 的 enctype 等于这个值。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。这个和application/x-www-form-urlencoded的区别在于一个适合传字段键值，一个适合传文件。

* text/xml

> 和application/json的区别是把传输的格式换成xml格式，结构复杂，臃肿。反正我是不会用。

那么使用axios需要怎样设置才能使用 `application/x-www-form-urlencoded` 编码格式呢（比较特殊）？
如果我们需要采用表单上传的方式（application/x-www-form-urlencoded）来给后台传递数据的话，则需要引入qs库,qs库在我们 安装 axios的时候就已经给我们默认安装了 这个时候 我们需要将参数转换一下:

```
import qs from 'qs'
export function post (url, data = {}) {
  return new Promise((resolve, reject) => {
    axios.post(url, qs.stringify(data))
      .then(response => {
        resolve(response.data)
      }, err => {
        reject(err)
      })
  })
```13:T1282,![](http://developers-center.oss-cn-beijing.aliyuncs.com/image.png)

记录一下js兼容各个浏览器的启动和退出全屏方法

JS标准API其实已经包含了相关的几个方法：

* 全屏是否可用：[Document.fullscreenEnabled](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocument%2FfullscreenEnabled)
* 开启全屏：[Document.requestFullScreen()](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FElement%2FrequestFullScreen)
* 退出全屏：[Document.exitFullscreen()](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FDocument%2FexitFullscreen)
* 获取全屏元素：[document.mozFullScreenElement](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FDocument%2FfullscreenElement)
* 监听全屏模式变化: [fullscreenchange](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FDocument%2Ffullscreenchange_event)

## 全屏js库推荐

* [be-full🚀](https://www.npmjs.com/package/be-full)
> 全屏显示, 支持PC/移动端, 不到1kb. 🚀[在线演示](https://any86.github.io/be-full/example/)

## 全屏是否可用： Document.fullscreenEnabled

`fullscreenEnabled` 属性提供了启用全屏模式的可能性。当它的值是 `false` 的时候，表示全屏模式不可用（可能的原因有 "`fullscreen`" 特性不被允许，或全屏模式不被支持等 ）

```
function fullscreenEnabled() {
  return (
    document.fullscreenElement ||
    document.mozFullScreenElement ||
    document.webkitFullscreenElement
  );
}
```

## 启动全屏： Document.exitFullscreen()

`Element.requestFullscreen()` 方法用于发出异步请求使元素进入全屏模式。作用是请求浏览器将指定的元素设置为全屏模式， 结果会返回一个`Promise`，全屏模式被激活的时候变成 `resolved` 状态。

如果全屏模式被禁用或者不支持，则会返回`reject`。`Document.fullscreenEnabled` 可用来判断是否支持全屏模式。

```
function fullscreen(element) {
  if (document.mozFullScreenEnabled) {
    return Promise.reject(new Error("全屏模式被禁用"));
  }
  let result = null;
  if (element.requestFullscreen) {
    result = element.requestFullscreen();
  } else if (element.mozRequestFullScreen) {
    result = element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    result = element.msRequestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    result = element.webkitRequestFullScreen();
  }
  return result || Promise.reject(new Error("不支持全屏"));
}
```

## 退出全屏：Document.exitFullscreen()

`Document.exitFullscreen()`  方法用于让当前文档退出全屏模式。元素恢复到之前的状态。

MDN有这样的一个备注：

> 如果一个元素A在请求进去全屏模式之前，已经存在其他元素处于全屏状态，当这个元素A退出全屏模式之后，之前的元素仍然处于全屏状态。浏览器内部维护了一个全屏元素栈用于实现这个目的

> Document.exitFullscreen() 方法让全屏元素栈的栈顶元素退出全屏状态，并让新的栈顶的元素进入全屏状态

这就意味着可以有多个元素同时全屏。并且这些全屏的元素被存储在一个栈中。

```
function cancelFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  }
}
```

## 获取全屏元素：document.mozFullScreenElement

该方法可以用来检查当前是否有元素处于全屏状态，如果有，则返回该元素，如果没有则返回null。

```
  if (document.fullscreenElement === null) {
    console.log("当前处于全屏模式");
  } else {
    console.log("当前不处于全屏模式");
  }
```

## 监听全屏模式变化: fullscreenchange

实际业务中一般会存在监听全屏模式变化，例如：非全屏模式时候显示"全屏"按钮，全屏时候显示"退出全屏"按钮。这就需要我们监听全屏状态来控制操作按钮的显示与隐藏。

```
let isFullscreen = false;

const handler = () => {
  isFullscreen = document.fullscreenElement !== null;
  if (!isFullscreen) {
    // 退出全屏时候解除监听，不然每次监听都会添加一次绑定 
    document.removeEventListener("fullscreenchange", handler);
  }
};

document.addEventListener("fullscreenchange", handler);
```14:T224e,## 背景

之前的demo加了图片预览，所以今天下午追番剧之后突然想到能不能做一个pdf的在线预览。动手吧。一开始我查了很多教程，发现很多人都在说pdf.js的库当然这个没问题。Pdf.js确实可以完美的实现Pdf在线预览的过程，但是我觉得这样直接走就不优雅了。于是我找现成的组件，找到了vue-pdf。虽然没有native那么强大，比如不支持pdf文本复制，打印会有乱码，但是我感觉已经足够满足我的需求了。这个笔记是一步一步的，从基础演示到能用的程度。文章最后列举了你在实际使用过程中可能遇到的问题和解决方法。

## 安装：

```
npm install --save vue-pdf
```

## vue-pdf 初体验：

安装完成后，使用vue-pdf非常简单，和其他组件没什么区别。代码如下:

引入组件：

```
<script>
import pdf from 'vue-pdf'
export default {
  components:{
      pdf
  },
  data(){
      return {
          url:"http://storage.xuetangx.com/public_assets/xuetangx/PDF/PlayerAPI_v1.0.6.pdf",
      }
  }
</script>   
```

然后在页面上用vue-pdf，加标签就行了：

```
<template>
<div>
  <pdf 
    ref="pdf"
    :src="url">
  </pdf>
</div>
</template>
```

重启你的项目，访问这个界面，你会发现pdf已经大概率成功显示在你的界面上了。没有问题，但是，就在你准备拿起一根烟，点燃它，和舒适美丽的索罗河一起享受你成功的杰作的时候，你会发现，* *神圣的狗屎，为什么只有一页* *，当眼镜碰在一起，梦碎的声音充斥世界。

所以，这只是第一次经历。如果你的pdf只有一页，当然这样写是没有问题的。但是当我们的pdf有很多页的时候，你会发现它不行了。所以，接下来，我们来看看如何让它显示多个页面。

## vue-pdf 渐入佳境：

其实显示多个页面也没那么复杂。一次显示一页。我，直接v-for循环，直接显示。简单粗暴。

页面代码:

```
<template>
	<div>
	<pdf  v-for="i in numPages" :key="i"  :src="url" :page="i"></pdf>	
	</div>
</template>

<script>
	import pdf from 'vue-pdf'
	export default {
		components: {
			pdf
		},
		data(){
			 return{
				    url: '',
				    numPages:1,
			 }
		 },
		mounted: function() {
		  this.getNumPages("http://storage.xuetangx.com/public_assets/xuetangx/PDF/PlayerAPI_v1.0.6.pdf")
		  
		}, 
		methods: {
			getNumPages(url) {
				var loadingTask = pdf.createLoadingTask(url)
				loadingTask.then(pdf => {
					this.url = loadingTask
					this.numPages = pdf.numPages
				}).catch((err) => {
					console.error('pdf加载失败')
				})
			},
		}
	}
</script>
```

属性：

-   url ：pdf 文件的路径，可以是本地路径，也可以是在线路径。
-   numPages ： pdf 文件总页数。

getNumPages 计算总页数，顺便给url和numPages赋值。

你唯一需要注意的就是这句话:

```
this.getNumPages("http://storage.xuetangx.com/public_assets/xuetangx/PDF/PlayerAPI_v1.0.6.pdf")
```

注意啊，这句不一定非要写到mounted里面，你想写哪就写哪，比如你前端请求后端，后端返回一个pdf 的url，在那里写就行，写在你需要的地方。

## vue-pdf 轻车熟路：

很多人看到这个，就在这里，就在这里？万一我的pdf有一千页，我的浏览器应该不会被破解。我追求的是在一个微醺的下午翻阅书页的感觉。你能给我吗？

不行，不行，我保证让你满意。

```
<template>
	<div>
		<div class="tools">
			<bk-button :theme="'default'" type="submit" :title="'基础按钮'" @click.stop="prePage" class="mr10"> 上一页</bk-button>
			<bk-button :theme="'default'" type="submit" :title="'基础按钮'" @click.stop="nextPage" class="mr10"> 下一页</bk-button>
			<div class="page">{{pageNum}}/{{pageTotalNum}} </div>
			<bk-button :theme="'default'" type="submit" :title="'基础按钮'" @click.stop="clock" class="mr10"> 顺时针</bk-button>
			<bk-button :theme="'default'" type="submit" :title="'基础按钮'" @click.stop="counterClock" class="mr10"> 逆时针</bk-button>
		</div>
		<pdf ref="pdf" 
		:src="url" 
		:page="pageNum"
		:rotate="pageRotate"  
		@progress="loadedRatio = $event"
		@page-loaded="pageLoaded($event)" 
		@num-pages="pageTotalNum=$event" 
		@error="pdfError($event)" 
		@link-clicked="page = $event">
		</pdf>
	</div>
</template>
```

接下来，我们来介绍一下这些是什么。

参数介绍：

-   `page`: 当前显示的页数，比如第一页page=1
-   `rotate` ： 旋转角度，比如0就是不旋转，+90，-90 就是水平旋转。
-   `progress` ：当前页面的加载进度，范围是0-1 ，等于1的时候代表当前页已经完全加载完成了。
-   `page-loaded` ：页面加载成功的回调函数，不咋能用到。
-   `num-pages` ：总页数
-   `error` ：加载错误的回调
-   `link-clicked`：单机pdf内的链接会触发。

其他：

-   print 这个是打印函数。 注意：谷歌浏览器会出现乱码，这个和字体有关系。

来，js代码走一个:

```
<script>
	import pdf from 'vue-pdf'
	export default {
		name: 'Home',
		components: {
			pdf
		},
		data() {
			return {
				url: "http://storage.xuetangx.com/public_assets/xuetangx/PDF/PlayerAPI_v1.0.6.pdf",
				pageNum: 1,
				pageTotalNum: 1,
				pageRotate: 0,
				// 加载进度
				loadedRatio: 0,
				curPageNum: 0,
			}
		},
		mounted: function() {},
		methods: {
            // 上一页函数，
			prePage() {
				var page = this.pageNum
				page = page > 1 ? page - 1 : this.pageTotalNum
				this.pageNum = page
			},
            // 下一页函数
			nextPage() {
				var page = this.pageNum
				page = page < this.pageTotalNum ? page + 1 : 1
				this.pageNum = page
			},
            // 页面顺时针翻转90度。
			clock() {
				this.pageRotate += 90
			},
            // 页面逆时针翻转90度。
			counterClock() {
				this.pageRotate -= 90
			},
            // 页面加载回调函数，其中e为当前页数
			pageLoaded(e) {
				this.curPageNum = e
			},
            // 其他的一些回调函数。
			pdfError(error) {
				console.error(error)
			},
		}
	}
</script>
```

其他Sao操作:

```
// 打印全部
pdfPrintAll() {
	this.$refs.pdf.print()
		},
// 打印指定部分
pdfPrint() {
	this.$refs.pdf.print(100, [1, 2])
	},
```

具体风格什么的我就不贴了。这些都不是重点，可以改成自己的。

成品展示:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ad8892249345e5a2fb29295a7e4983~tplv-k3u1fbpfcp-zoom-1.image)

## 其他问题以及解决方案：

### 如何加载本地pdf文件(2020.4.27更新)：

评论区有人提到这个问题。我今天中午试了一下，没问题，但是我们需要在本地配置flie-loader。否则webpack无法编译pdf文件，配置方法非常简单。在项目根目录新建一个vue.config.js文件，我发现很多人只是去babel.config.js配置一下。这是错误的，肯定会给出错误。

先安装file-loader:

```
npm install --save file-loader
复制代码
```

然后在vue.config.js中加入以下内容：

```
module.exports = {
    chainWebpack: config => {
        const fileRule = config.module.rule('file')
        fileRule.uses.clear()
        fileRule
            .test(/.pdf|ico$/)
            .use('file-loader')
            .loader('file-loader')
            .options({
                limit: 10000,
            })
    },
    publicPath: './'
}
```

之后再`url:require("../assets/1.pdf")`就没有任何问题了，注意，vue-pdf src接收的是string对象，如果直接传url我这里报错了，你可能需要传`url.default`一下。

### 跨域问题：

网上用pdf.js 很多都会遇到跨域问题，这个我今天实际应用到自己的项目里面了，由于我服务端设置了跨域，所以没有出现跨域的问题，如果出现跨域需要修改你后端的请求头。

### 打印界面字符乱码：

这个我倒是碰到了，谷歌浏览器打印的时候，预览界面真的变成了 真·方块字 ，全是方块。这个问题是因为你pdf中使用了自定义字体导致的，具体解决方案如下：

首先，找到这个文件：node_modules/vue-pdf/src/pdfjsWrapper.js

然后根据github上这个issue，其中红色的是要删掉的，绿色的是要加上去的，照着改就可以解决了。

地址： [github.com/FranckFreib…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FFranckFreiburger%2Fvue-pdf%2Fpull%2F130%2Fcommits%2F253f6186ff0676abf9277786087dda8d95dd8ea7 "https://github.com/FranckFreiburger/vue-pdf/pull/130/commits/253f6186ff0676abf9277786087dda8d95dd8ea7")

根据我的实际测试，是可以解决打印乱码的问题的。15:Tcd5,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_javascript_frameworks_-8-qpc.svg)

## 项目结构

```
├─public
└─src
    ├─assets
    │  ├─images
    │  └─svg
    ├─components
    │  └─custom-component.vue
    ├─core
    │  ├─api
    │  ├─libs
    │  ├─links
    │  └─utils
    │      └─request.js
    ├─layouts
    ├─pages
    │  └─index.vue
    ├─plugins
    ├─router
    │   └─index.js
    ├─stores
    ├─styles
    └─themes
```

## 在js中使用路由跳转

在vue3中我们使用comAPI，但是在自己封装的js里面，我们不能使用useRouter ,useRoute，他们需要在setup中调用执行后才能用，我们需要使用路由实例：

`/src/core/utils/request.js`

```js
import router from '../../router';
router.push('/login')
```

## 定义v-model属性

`/src/components/custom-component.vue`
```
<template>
  <div>{{infos}}</div>
</template>
<script setup>
const props = defineProps(['infos'])
const emits = defineEmits(['update:infos'])
setTimeout(() => {
  emits('update:infos', 'hello v-model')
}, 2000)
</script>
```

使用自定义组件

`/src/pages/index.vue`

```
<template>
  <div>
    <custom-component v-model:infos="infos"></custom-component>
  </div>
</template>

<script setup>
import {ref} from 'vue';
import CustomComp from '../components/custom-component.vue';
const infos = ref('hello custom-comp');
</script>
```

## 父组件调用子组件方法

`子组件 Child.vue`

```
<template>
  <div>子页面计数：{{ count }}</div>
</template>

<script setup>
import { ref } from "vue";

const count = ref(0);
const add = () => {
  count.value++;
};
const addCustom = (value) => {
  count.value += value;
};
defineExpose({
  add,
  addCustom
})
</script>
```

`父组件 Index.vue`
```
<template>
  <div>
    <Child ref="child"></Child>
    <br />
    父页面按钮：<button @click="handleAdd">点击+1</button>
    <br />
    父页面按钮：<button @click="handleAddCustom">(添加自定义数值)点击+10</button>
  </div>
</template>

<script setup>
import { ref } from "vue";
import Child from "./Child";

const child = ref();
const handleAdd = () => {
  child.value.add();
};
const handleAddCustom = () => {
  child.value.addCustom(10);
};
</script>
```
## 使用 keep-alive 缓存组件状态

1. 修改 `<router-view></route-view>` 部分

    ```
    <template>
      <router-view v-slot="{ Component }">
        <keep-alive>
          <component :is="Component"/>
        </keep-alive>
      </router-view> 
    </template>
    ```

2. 子组件状态刷新

    - 方案一 使用 `keep-alive` 的生命周期：`activated`
    
        `child.vue`
        ```
        <script setup>
            activated() {
               // TODO: 这里处理需要刷新的状态
            },
        </script>
        ```
    - 方案二 通过监听路由等发生改变需要改变的场景
    
        `child.vue`

        ```
        <script setup>
        import {watch} from 'vue';
        import {useRoute} from 'vue-router';
        const route = useRoute();
        watch(() => route.params.id, (id) => {
          // TODO: 这里处理需要刷新的状态
        });
        </script>
        ```16:Tbef,![](https://developers-center.oss-cn-beijing.aliyuncs.com/undraw_static_assets_rpm6.svg)

## 微信webview

判断网页是否在微信中打开;

```js
function isWeChat() {
    return (/MicroMessenger/i.test(window.navigator.userAgent));
}
```

## Android系统

判断网页是否在安卓系统中打开;

```js
function isAndroid() {
    return /Android/i.test(navigator.userAgent) || /Linux/i.test(navigator.appVersion);
}
```
## 苹果手机

判断网页是否在苹果手机中打开;

```js
function isIphone() {
    return /iPhone/i.test(navigator.userAgent);
}
```

## Ios系统

判断网页是否在Ios系统中打开;

```js
function isIOS() {
    return (/ipad|iphone/i.test(navigator.userAgent));
}
```
## Safari浏览器

判断网页是否在Safari浏览器中打开;

```js
function isSafari() {
    return (/msie|applewebkit.+safari/i.test(navigator.userAgent));
}
```

## Windows

判断网页是否在Windows系统中打开;

```js
function isWindows() {
    return /windows|win32/i.test(navigator.userAgent);
}
```

## Mac

判断网页是否在Mac系统中打开;

```js
function isMac() {
    return /macintosh|mac os x/i.test(navigator.userAgent);
}
```

## 移动端(手机)

判断网页是否在移动端打开;

```js
function isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
}
```

## PWA(Progressive web apps，渐进式 Web 应用)

判断网页是否以PWA模式打开;

```js
function isPwa() {
    return ["fullscreen", "standalone", "minimal-ui"].some(
        (displayMode) => window.matchMedia('(display-mode: ' + displayMode + ')').matches
    );
}
```

## 完整代码可直接复制使用

`runtime-env.js` `runtime-env.ts`

```js
export class RuntimeEnv {
  /**
   * 微信webview
   * @return {boolean}
   */
  static isWeChat() {
    return (/MicroMessenger/i.test(window.navigator.userAgent));
  }
  /**
   * Android系统
   * @return {boolean}
   */
  static isAndroid() {
    return /Android/i.test(navigator.userAgent) || /Linux/i.test(navigator.appVersion);
  }
  /**
   * 苹果手机
   * @return {boolean}
   */
  static isIphone() {
    return /iPhone/i.test(navigator.userAgent);
  }
  /**
   * Ios系统
   * @return {boolean}
   */
  static isIOS() {
    return (/ipad|iphone/i.test(navigator.userAgent));
  }
  /**
   * Safari浏览器
   * @return {boolean}
   */
  static isSafari() {
    return (/msie|applewebkit.+safari/i.test(navigator.userAgent));
  }
  /**
   * Windows
   * @return {boolean}
   */
  static isWindows() {
    return /windows|win32/i.test(navigator.userAgent);
  }
  /**
   * Mac
   * @return {boolean}
   */
  static isMac() {
    return /macintosh|mac os x/i.test(navigator.userAgent);
  }
  static isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  }
  static isPwa() {
    return ["fullscreen", "standalone", "minimal-ui"].some(
        (displayMode) => window.matchMedia('(display-mode: ' + displayMode + ')').matches
    );
  }
}
```17:T1be0,iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。

笔者通过查阅了一些官方文档，以及结合实际项目中的一些处理经验，整理了一套简单的适配方案分享给大家，希望对大家有所帮助，以下是处理前后效果图：

![](http://developers-center.oss-cn-beijing.aliyuncs.com/2692140-3ce5b351236f8139.png)

## 适配之前需要了解的几个新知识

### 安全区域

安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域：

![](http://developers-center.oss-cn-beijing.aliyuncs.com/2692140-d9540c615721d55f.png)

也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。

更详细说明，参考文档： [Human Interface Guidelines - iPhoneX](https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/)

### viewport-fit

iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值：

-   contain: 可视窗口完全包含网页内容（左图）
-   cover：网页内容完全覆盖可视窗口（右图）
-   auto：默认值，跟 contain 表现一致

![](http://developers-center.oss-cn-beijing.aliyuncs.com/2692140-a6dde8b38ea30aff.png)

> 注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。

更详细说明，参考文档： [viewport-fit-descriptor](https://www.w3.org/TR/css-round-display-1/#viewport-fit-descriptor)

### env() 和 constant()

iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量：

-   safe-area-inset-left：安全区域距离左边边界距离
-   safe-area-inset-right：安全区域距离右边边界距离
-   safe-area-inset-top：安全区域距离顶部边界距离
-   safe-area-inset-bottom：安全区域距离底部边界距离

这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。

> 注意：当 viewport-fit=contain 时 env() 是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。

在这之前，笔者使用的是 constant()，后来，官方文档加了这么一段注释（坑）：

> The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.

这就意味着，之前使用的 constant() 在 iOS11.2 之后就不能使用的，但我们还是需要做向后兼容，像这样：

```
padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS < 11.2 */
padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */
```

注意：env() 跟 constant() 需要同时存在，而且顺序不能换。

更详细说明，参考文档： [Designing Websites for iPhone X](https://webkit.org/blog/7929/designing-websites-for-iphone-x/?hmsr=funteas.com&utm_medium=funteas.com&utm_source=funteas.com)

## 如何适配

了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。

### 第一步：设置网页在可视窗口的布局方式

新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：

```
<meta name="viewport" content="width=device-width, viewport-fit=cover">
```

前面也有提到过，只有设置了 viewport-fit=cover，才能使用 env()。

### 第二步：页面主体内容限定在安全区域内

这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。

```
body {
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}
```

### 第三步：fixed 元素的适配

#### 类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况：


![](http://developers-center.oss-cn-beijing.aliyuncs.com/2692140-2418ec8e3d444790.png)

可以通过加内边距 padding 扩展高度：

```
{
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}
```

或者通过计算函数 calc 覆盖原来高度：

```
{
  height: calc(60px(假设值) + constant(safe-area-inset-bottom));
  height: calc(60px(假设值) + env(safe-area-inset-bottom));
}
```

> 注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。

还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样：

```
{
  margin-bottom: constant(safe-area-inset-bottom);
  margin-bottom: env(safe-area-inset-bottom);
}
```

空的颜色块：

```
{
  position: fixed;
  bottom: 0;
  width: 100%;
  height: constant(safe-area-inset-bottom);
  height: env(safe-area-inset-bottom);
  background-color: #fff;
}
```

#### 类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等

像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：

```
{
  margin-bottom: constant(safe-area-inset-bottom);
  margin-bottom: env(safe-area-inset-bottom);
}
```

或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：

```
{
  bottom: calc(50px(假设值) + constant(safe-area-inset-bottom));
  bottom: calc(50px(假设值) + env(safe-area-inset-bottom));
}
```

### 你也可以使用 @supports 隔离兼容样式

写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响：

```
@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {
  div {
    margin-bottom: constant(safe-area-inset-bottom);
    margin-bottom: env(safe-area-inset-bottom);
  }
}
```

## 写在最后

以上几种方案仅供参考，笔者认为，现阶段适配处理起来是有点折腾，但是至少能解决，具体需要根据页面实际场景，在不影响用户体验与操作的大前提下不断尝试与探索，才能更完美的适配。

来源: [京东零售官方设计体验平台](https://jelly.jd.com/article/6006b1055b6c6a01506c87fd)18:T605,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_javascript_frameworks_-8-qpc.svg)

## 背景

项目中的多个页面其中的变量及方法重复出现，每个页面组件都去手写一遍，这样的代码量太大，不利于维护。

其次这样的代码也不是特别优雅，那么如何让代码更优雅呢？熟悉面向对象编程的选手都会想到通过继承去把相似的类的操作通过继承来实现。

那么这样的继承在vue中怎么实现呢？

## 环境

* ![](https://img.shields.io/badge/vue-2.6.10-green)
* ![](https://img.shields.io/badge/vue--cli-4.5.17-green)
* ![](https://img.shields.io/badge/typescript-4.7.3-blue)
* ![](https://img.shields.io/badge/vue--class--component-^7.2.6-green)
* ![](https://img.shields.io/badge/vue--property--decorator-^9.1.2-green)

## 实现

上面理论有了 接下来就是实践了

### 创建 mixin 文件

`test.mixin.ts`

```typescript
import { Vue, Provide, Component } from "vue-property-decorator";
@Component
export default class TestMixin extends Vue {
  @Provide() protected version: string = "1.0.0";
}
```

### 使用 mixins

```

<template>
  <button @click="handlerClick">button</button>
</template>

<script lang="ts">
import TestMixin from "@/mixins/test.mixin";
import Test2Mixin from "@/mixins/test2.mixin";
import {Component, Mixins} from "vue-property-decorator";

@Component()
export default class Home extends Mixins(TestMixin, Test2Mixin) {
  private handlerClick() {
    console.log(this.version);
  }
}
</script>

```
19:T8b2,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_javascript_frameworks_-8-qpc.svg)

## 背景

在维护已有的 vue 2 项目的时候引入了 typescript 进行混合开发，新的模块使用 typescript 开发，旧的模块使用 vue 开发，这样的混合开发方式 [具体混合方案可以看这里](http://developer.bulv.life/blogs/62a7e9c7957f80472322d084)，在开发过程中会出现一些问题，比如：

项目中ts文件及组件只能使用相对路径，那么就会出现类似如下的代码：

```js
import Button from '../../../../components/upload/Upload'
```
很显然，这样的路径很长，如果组件层次很深，那么相对路径就会很长，因此这种情况下很有必要使用绝对路径。

## 环境

* ![](https://img.shields.io/badge/vue-2.6.10-green)
* ![](https://img.shields.io/badge/vue--cli-4.5.17-green)
* ![](https://img.shields.io/badge/typescript-4.7.3-blue)

## 解决方案

在webpack中，使用alias功能，可以使得我们使用绝对路径. `webpack.config.js`

```js
module.exports = {
  //...
  resolve: {
    alias: {
      '@src': path.resolve(__dirname, '../src')
    }
  }
}
```

而我们的项目为 vue-cli 4.x，所以我们只需要在 `vue.config.js` 中配置 `resolve` 属性，并且配置 `alias` 属性，这样我们就可以使用绝对路径了。

`vue.config.js`

```js
const path = require("path");
module.exports = {
  configureWebpack: {
    resolve: {
      alias: {
        "@": path.resolve(__dirname, "./src"),
      }
    }
  }
}
```
而项目本身在未进行ts混合开发的时候，就不需要配置 `resolve` 属性，便可以直接使用绝对路径了，这是由于 vue-cli 已经默认帮我们配置好了。 

由此看来我们的项目并非是 `webpack` 配置引发的无法使用绝对路径的问题，而是 typeScript 不认识webpack的配置的绝对路径的问题。

所以在 `tsconfig.json` 中配置 `compilerOptions` 属性，并且配置 `paths` 属性，这样我们就可以使用绝对路径了。

```json
{
  "baseUrl": ".",
  "compilerOptions": {
    "paths": {
      "@/*": [
        "src/*"
      ]
    }
  }
}
```

到此我们就可以放心使用绝对路径了。1a:T679,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_javascript_frameworks_-8-qpc.svg)
## 环境

* ![](https://img.shields.io/badge/vue-2.6.10-green)
* ![](https://img.shields.io/badge/vue--cli-4.5.17-green)
* ![](https://img.shields.io/badge/typescript-4.7.3-blue)

## 配置


配置比较简单，直接贴代码了：

```
// vue.config.js

const { ESBuildMinifyPlugin } = require('esbuild-loader');

module.exports = {
  // ...

  chainWebpack: (config) => {
    // 使用 esbuild 编译 js 文件
    const rule = config.module.rule('js');

    // 清理自带的 babel-loader
    rule.uses.clear();

    // 添加 esbuild-loader
    rule
      .use('esbuild-loader')
      .loader('esbuild-loader')
      .options({
        loader: 'ts', // 如果使用了 ts, 或者 vue 的 class 装饰器，则需要加上这个 option 配置， 否则会报错： ERROR: Unexpected "@"
        target: 'es2015',
        tsconfigRaw: require('./tsconfig.json')
      })

    // 删除底层 terser, 换用 esbuild-minimize-plugin
    config.optimization.minimizers.delete('terser');

    // 使用 esbuild 优化 css 压缩
    config.optimization
      .minimizer('esbuild')
      .use(ESBuildMinifyPlugin, [{ minify: true, css: true }]);
  }
}

```

## 了解 esbuild


1.  [「 不懂就问 」esbuild 快在哪里 ?](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000040076960 "https://segmentfault.com/a/1190000040076960")
1.  [「 不懂就问 」webpack 打包的性能瓶颈在哪里 ？](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000040083830 "https://segmentfault.com/a/1190000040083830")1b:T6e3,
![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_javascript_frameworks_-8-qpc.svg)


写习惯ts后就不想写js了，正好把手头的纯js项目转成混合的，新代码用ts，旧代码慢慢改造

## package.json需要下载的库

```
// webpack中的ts-loader
"ts-loader"
// 不解释
"typescript"
// 下面两个是vue ts相关的
"vue-class-component"
"vue-property-decorator"
```

## tsconfig相关（配置完后要重启IDE）

1.  根目录建一个 **vue-shim.d.ts** 文件

```
declare module '*.vue' {
  import Vue from 'vue';

  export default Vue;
}

// overwrite window，这块代码只是举个例子，根据你需要来
interface Window {
  _actions: Array<string>;
}

```

2.  根目录建一个 **tsconfig.json** 文件

```
{
  "compilerOptions": {
    "baseUrl": ".",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "strict": true,
    "allowJs": true,
    "sourceMap": true,
    "moduleResolution": "node"
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
  ],
  "files": [
    "./vue-shim.d.ts"
  ]
}
```

## webpack配置(vue.config.js)

因为是使用vue-cli创建的项目，所以在vue.config.js里修改。只需要修改三个地方就好

```

module.exports = {
    resolve: {
        extensions: ['.ts', '.tsx', '.js', '.json'],
    }
    configureWebpack: {
        resolve: { extensions: [".ts", ".tsx", ".js", ".json"] },
        module: {
            rules: [
                {
                  test: /\.tsx?$/,
                  loader: 'ts-loader',
                  exclude: /node_modules/,
                  options: {
                    appendTsSuffixTo: [/\.vue$/],
                  }
                }
            ]
        }
    }
}
```1c:Tac5,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_static_assets_rpm6.svg)
## 1.在 color 中配置渐变色：

[echarts 配置项](https://echarts.apache.org/zh/option.html)

```javascript
// 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比，如果 globalCoord 为 `true`，则该四个值是绝对的像素位置
const linearGradientColor = {
    type: 'linear',
    x: 0,
    y: 0,
    x2: 0,
    y2: 1,
    colorStops: [{
        offset: 0, color: 'red' // 0% 处的颜色
    }, {
        offset: 1, color: 'blue' // 100% 处的颜色
    }],
    globalCoord: false // 缺省为 false
};
// 径向渐变，前三个参数分别是圆心 x, y 和半径，取值同线性渐变
const radialGradientColor = {
    type: 'radial',
    x: 0.5,
    y: 0.5,
    r: 0.5,
    colorStops: [{
        offset: 0, color: 'red' // 0% 处的颜色
    }, {
        offset: 1, color: 'blue' // 100% 处的颜色
    }],
    globalCoord: false // 缺省为 false
}
// 纹理填充
const textureFillColor = {
    image: imageDom, // 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串
    repeat: 'repeat' // 是否平铺, 可以是 'repeat-x', 'repeat-y', 'no-repeat'
}
const option = {
    series: [
        {
            type: 'line',
            areaStyle: {
                color: linearGradientColor||radialGradientColor||textureFillColor
            },
        },
    ],
};
chart.setOption({option})
```

## 2.使用echarts内置的渐变色生成器echarts.graphic.LinearGradient

echarts的官方API中都没有对这个API添加说明文档, 故用本篇文章来简略说明其用法.

```javascript
const color = new echarts.graphic.LinearGradient(
    0, 0, 0, 1,
    [
        {offset: 0, color: '#000'},
        {offset: 0.5, color: '#888'},
        {offset: 1, color: '#ddd'}
    ]
);
const option = {
    series: [
        {
            type: 'line',
            areaStyle: {
                color: color,
            },
        },
    ],
};
chart.setOption({option})
```

0，0，0，1分别代表了右、下、左、上四个位置的颜色坐标

通过修改这4个参数, 可以实现不同的渐变方向, 如:
0 1 0 0 代表从正下方向正上方渐变;
1 0 0 1 代表从右上方向左下方渐变,

第5个参数则是一个数组, 用于配置颜色的渐变过程. 每一项为一个对象, 包含offset和color两个参数. offset的范围是0 ~ 1, 用于表示位置, color不用多说肯定是表示颜色了. 像示例代码的配置则表示:
整个渐变过程是从正上方向正下方变化
起始(offset: 0)颜色为#000, 变化到正中间(offset: 0.5)位置时颜色为#888, 变化到结束(offset: 1)位置时颜色为#ddd.1d:Td10,## 起源

### 介绍

这是一个用于 生产环境的 React 框架

Next.js 为您提供生产环境所需的所有功能以及最佳的开发体验：包括静态及服务器端融合渲染、 支持 TypeScript、智能化打包、 路由预取等功能 无需任何配置。

为什么选择 Next.js (全球领先的公司都在使用并喜爱 Next.js)

* 零配置 - 自动编译并打包。从一开始就为生产环境而优化。
* 混合模式： SSG 和 SSR - 在一个项目中同时支持构建时预渲染页面（SSG）和请求时渲染页面（SSR）。
* 增量静态生成 - 在构建之后以增量的方式添加并更新静态预渲染的页面。
* 支持 TypeScript - 自动配置并编译 TypeScript。
* 快速刷新 - 快速、可靠的实时编辑体验，已在 Facebook 级别的应用上规模上得到验证。
* 基于文件系统的路由 - 每个 pages 目录下的组件都是一条路由。
* API 路由 - 创建 API 端点（可选）以提供后端功能。
* 内置支持 CSS - 使用 CSS 模块创建组件级的样式。内置对 Sass 的支持。
* 代码拆分和打包 - 采用由 Google Chrome 小组创建的、并经过优化的打包和拆分算法。

以上内容均摘录自 [Next.js 中文官网](https://www.nextjs.cn/)

### 为什么是 Next.js

如你所见读到这篇文章的时候， 你已经身处于 Next.js 生产的网站之中了， 或许她并不完美，但是你可以通过她来了解到， Next.js 的一些特性，以及帮助你判断是否需要选择 Next.js 。

首先本网站完全使用 Next.js 构建， 她是一个技术类网站，那么她就需要更多的出现在你们的视野之中，
那么这一点是和我们常见的管理系统web应用是不同的，那么我们就了解到她需要更好的 SEO 支持，
而在前端框架大行其道的时下，我们都习惯于使用 Create React App 等构建工具构建现代化的 Web 应用，
但 Create React App 只是一个构建工具，并不是一个完整的框架，其构建的结果是 SPA 单页应用，
作为 Web 开发人员 我们都了解到 SPA 单页应用对于 SEO 支持并不友好，
再者使传统 SPA 单页应用对 SEO 更好地支持需要较多的配置等操作以及较多解决方案使我们难以选择，那么 Next.js 就是一个更好的选择，
正如 Next.js 官网所提到的特性，大大降低了我们搭建应用的成本，这也是本网站使用 Next.js 的原因。

## 现在开始

### 创建 Next.js 应用

若要创建 Next.js 应用，请打开终端，进入要在其中创建应用的目录，然后运行以下命令

```shell
npx create-next-app nextjs-blog --use-npm --example "https://github.com/vercel/next-learn/tree/master/basics/learn-starter"
```

### 运行开发服务器

```shell
cd nextjs-blog
npm run dev
```

这将在端口 3000 上启动 Next.js 应用的“开发服务器” 从浏览器打开http://localhost:3000

当您访问 http://localhost:3000 时，您应该会看到这样的页面。这是入门模板页面，其中显示了有关Next.js的一些有用信息。

![](http://developers-center.oss-cn-beijing.aliyuncs.com/welcome-to-nextjs.png)
## 结束语

到此一个最简单的 Next.js 应用就创建成功了 在接下来的文章中我将会持续为大家分享我们的应用的构建过程


1e:T10e4,![](https://pic3.zhimg.com/80/v2-18f4b340b48c89daaafe0116405a543e_720w.jpg)

对应用程序进行Docker化非常简单，有效，但是优化Docker Image的大小是棘手的部分。 Docker易于使用，但是一旦应用程序开始扩展，镜像大小就会呈指数增长。通常，大多数情况下，应用程序的Node.js docker镜像大小超过1 GB。

### 为什么镜像大小很重要

* 较大的docker镜像需要更多空间，这意味着增加费用。
* 较长的构建时间-将镜像通过网络推送会花费更长的时间，并导致CI管道延迟。

### 让我们开始优化

这是使用VueJS应用程序构建的 [演示应用程序](https://link.zhihu.com/?target=https%3A//github.com/championshuttler/fluentbit-dashboard)。

这是初始的Dockerfile

```text
FROM node:10
WORKDIR /app
COPY . /app
EXPOSE 8080
RUN npm install http-server -g
RUN npm install && npm run build
CMD http-server ./dist
```
该镜像的大小约为1.34GB：

![](https://pic2.zhimg.com/80/v2-7c174001efb6585ef9588a7d9ea72a19_720w.jpg)

让我们开始逐步优化。

1. 使用多阶段Docker构建
    
   多阶段构建可通过在单个Dockerfile中使用多个中间镜像来轻松优化Docker镜像。在此处了解更多信息。通过使用多阶段构建，我们可以在构建镜像中安装所有依赖项，并将它们复制到精简运行时镜像中。
   
   ```text
   FROM node:10 AS BUILD_IMAGE
    WORKDIR /app
    COPY . /app
    EXPOSE 8080
    RUN npm install && npm run build
    FROM node:10
    WORKDIR /app
    # copy from build image
    COPY --from=BUILD_IMAGE /app/dist ./dist
    COPY --from=BUILD_IMAGE /app/node_modules ./node_modules
    RUN npm i -g http-server
    CMD http-server ./dist
   ```
   现在，此镜像的大小为1.24GB：
   
2. 删除开发依赖项并使用 Node Prune 工具

    node-prune是一个开源工具，用于从node_modules文件夹中删除不需要的文件。通常在生产环境中根本不需要Npm包中的测试文件，markdown文件，类型文件和* .map文件，大多数开发人员都不会从生产包中删除它们。通过使用node-prune，可以安全地将其删除。
    
    我们可以使用它来删除开发依赖项：
    
    ```shell
    npm prune --production
    ```
    
    进行这些更改后，Dockerfile 将如下所示：
    
    ```text
    FROM node:10 AS BUILD_IMAGE
    RUN curl -sfL https://install.goreleaser.com/github.com/tj/node-prune.sh | bash -s -- -b /usr/local/bin
    WORKDIR /app
    COPY . /app
    EXPOSE 8080
    RUN npm install && npm run build
    # remove development dependencies
    RUN npm prune --production
    # run node prune
    RUN /usr/local/bin/node-prune
    FROM node:10
    WORKDIR /app
    # copy from build image
    COPY --from=BUILD_IMAGE /app/dist ./dist
    COPY --from=BUILD_IMAGE /app/node_modules ./node_modules
    RUN npm i -g http-server
    CMD http-server ./dist
    ```
    
    通过使用此选项，我们将整体大小减小到1.09GB。
    
3. 选择较小的最终基础镜像
    
    在对Node.js应用程序进行docker化时，有很多基本镜像可供选择。
    
    这里我们将使用 alpine 镜像； alpine是一个精简的docker镜像，具有最少的软件包，但足以运行节点应用程序。
    
    ```text
    FROM node:10 AS BUILD_IMAGE
    RUN curl -sfL https://install.goreleaser.com/github.com/tj/node-prune.sh | bash -s -- -b /usr/local/bin
    WORKDIR /app
    COPY . /app
    EXPOSE 8080
    RUN npm install && npm run build
    # remove development dependencies
    RUN npm prune --production
    # run node prune
    RUN /usr/local/bin/node-prune
    FROM node:10-alpine
    WORKDIR /app
    # copy from build image
    COPY --from=BUILD_IMAGE /app/dist ./dist
    COPY --from=BUILD_IMAGE /app/node_modules ./node_modules
    RUN npm i -g http-server
    CMD http-server ./dist
    ```
    
    通过使用此Dockerfile，镜像大小降至157MB 。
    
    ![](https://pic2.zhimg.com/80/v2-5ea46fdb0a7079b37c3b6049404dbf29_720w.jpg)
    
### 结论
通过应用这3个简单步骤，我们将docker镜像大小减小了10倍。

PS: 本文属于翻译，[原文](https://link.zhihu.com/?target=https%3A//itsopensource.com/how-to-reduce-node-docker-image-size-by-ten-times/%3Futm_sq%3Dgi94nhjf7x)1f:T18cb,
如果你严肃对待编程，就必定会使用"[版本管理系统](https://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html)"（Version Control System）。

眼下最流行的"版本管理系统"，非[Git](https://git-scm.com/)莫属。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eff5ab7f7c349cb945fd235ca909abc~tplv-k3u1fbpfcp-zoom-1.image)

相比同类软件， Git 有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而 Git 只生成一个指向当前版本（又称"快照"）的指针，因此非常快捷易用。

但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eab76ecf796a41c183bfd5402d46a2c7~tplv-k3u1fbpfcp-zoom-1.image)

[Vincent Driessen](http://nvie.com/)提出了一个分支管理的[策略](http://nvie.com/posts/a-successful-git-branching-model/)，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用， Git 只是用来举例而已。如果你不熟悉 Git ，跳过举例部分就可以了。

**一、主分支Master**

首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7236b7b924bd4fe6ba60ac933b70f917~tplv-k3u1fbpfcp-zoom-1.image)

Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。

**二、开发分支Develop**

主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f96d0e26fc534bd4acd81667fb3fc4a0~tplv-k3u1fbpfcp-zoom-1.image)

这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行"合并"（merge）。

Git创建Develop分支的命令：
```shell
git checkout -b develop master
```

将Develop分支发布到Master分支的命令：
```shell
# 切换到Master分支\
git checkout master

# 对Develop分支进行合并\
git merge --no-ff develop
```

这里稍微解释一下，上一条命令的--no-ff参数是什么意思。默认情况下， Git 执行"快进式合并"（fast-farward merge），会直接将Master分支指向Develop分支。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903cd4ae680341e1985a6d1f0751fe9f~tplv-k3u1fbpfcp-zoom-1.image)

使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的[《Understanding the Git Workflow》](https://sandofsky.com/blog/git-workflow.html)。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e9f0547d6d541fc808047814d1fbb99~tplv-k3u1fbpfcp-zoom-1.image)

**三、临时性分支**

前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。

但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：

> * 功能（feature）分支
>
> * 预发布（release）分支
>
> * 修补bug（fixbug）分支

这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。

**四、 功能分支**

接下来，一个个来看这三种"临时性分支"。

第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/783d9ae482984afe8743dbcb4f28f666~tplv-k3u1fbpfcp-zoom-1.image)

功能分支的名字，可以采用feature-*的形式命名。

创建一个功能分支：
```shell
git checkout -b feature-x develop
```
开发完成后，将功能分支合并到develop分支：
```shell
git checkout develop

git merge --no-ff feature-x
```

删除feature分支：
```shell
git branch -d feature-x
```

**五、预发布分支**

第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。

预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。

创建一个预发布分支：
```shell
git checkout -b release-1.2 develop
```

确认没有问题后，合并到master分支：
```shell
git checkout master

git merge --no-ff release-1.2

# 对合并生成的新节点，做一个标签\
git tag -a 1.2
```
再合并到develop分支：
```shell
git checkout develop

git merge --no-ff release-1.2
```
最后，删除预发布分支：
```shell
git branch -d release-1.2
```

**六、修补bug分支**

最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。

修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bf2c6516741413da238520feb05d440~tplv-k3u1fbpfcp-zoom-1.image)

创建一个修补bug分支：
```shell
git checkout -b fixbug-0.1 master
```
修补结束后，合并到master分支：
```shell
git checkout master

git merge --no-ff fixbug-0.1

git tag -a 0.1.1
```

再合并到develop分支：
```shell
git checkout develop

git merge --no-ff fixbug-0.1
```

最后，删除"修补bug分支"：
```shell
git branch -d fixbug-0.1
```

作者： [阮一峰](https://www.ruanyifeng.com/)

日期： [2012年7月 5日](https://www.ruanyifeng.com/blog/2012/07/)20:T17d8,
![](http://developers-center.oss-cn-beijing.aliyuncs.com/微信图片_20220428202250.png)

最近接手了一个基于 uniapp 的开发项目，我个人对于它能够使用同一套代码就能够开发 h5\app\小程序 的强大功能表示非常钦佩。但是其配置文件 pages.json 也让我十分郁闷，原因无他，只因其是写死 JSON 文件，在管理的时候是十分不便的。

在搜索了一些资料，期望可以用 pages.js 文件来替代 pages.json 配置文件（JS的动态能力，可以很方便的拆分路由配置），但是没有找到很好的解决方案。倒是有一个，但是搞得过于繁琐，想想还是算球了。

于是，我自己用 Nodejs 手写了一个方案，虽然原始了一些，但是依赖十分轻，使用也比较便捷，个人感觉还是颇有用处的，所以特地撰文分享给大家。

## 构建文件构架

首先，我们在项目根目录中新建 `router` 文件夹，然后根据如下的格式构建文件结构。

```
router              # 动态路由文件夹
├── build.js        # 编译路由配置主文件
├── index.js        # 主配置文件
└── modules         # 动态路由模块文件
    └── small.js    # 拆分出来的模块路由文件
```
### 编写 `build.js` 文件

代码如下：

```
const fs = require('fs')
const path = require('path')
const router = require('./index.js')

// 将子路由模块配置文件转化为 uniapp 配置文件格式
const buildRouter = route => {
  const res = []
  const { baseUrl, children } = route
  children.forEach(i => {
    const obj = {
      path: baseUrl + i.path,
      style: {
        navigationBarTitleText: i.name
      }
    }
    Object.keys(i).forEach(ii => {
      !['path', 'name'].includes(ii) && (obj.style[ii] = i[ii])
    })
    res.push(obj)
  })
  return res
}

// 自动加载 './modules' 目录子路由配置文件
const getRouter = () => {
  const srcPath = path.resolve(__dirname, './modules')
  const result = fs.readdirSync(srcPath)
  let router = []
  result.forEach(r => {
    const route = require('./modules/' + r)
    router = [...router, ...buildRouter(route)]
  })
  return router
}

// 构建 pages 并写入 pages.json 文件
router.pages = getRouter()
fs.writeFile(
  __dirname + '/../pages.json',
  // 我这边是用两个空格来缩进 pages.json，如果喜欢制表符，第三个参数更换你为 \t 即可
  JSON.stringify(router, null, '  '),
  e => e ? console.error(e) : console.log('pages.json 配置文件更新成功')
)
```

`build.js` 文件为主文件，是用于编译 `pages.json` 的。如果你有 `nodejs` 编程基础的话，这是一个巨简单的问题。如果没有的话，就不用管了，直接复制走即可。

### 编写 index.js 文件

这个文件没啥说的，就是除了 `pages.json` 这个文件中的 `pages` 字段外的其他内容，导出即可。我这边示例文件如下：

```
module.exports = {
  globalStyle: {
    navigationBarTextStyle: 'white',
    navigationBarTitleText: '司机配送',
    navigationBarBackgroundColor: '#4a9ff8',
    backgroundColor: '#4a9ff8'
  },
  tabBar: {
    color: '#666',
    selectedColor: '#4a9ff8',
    backgroundColor: '#f7f7f7',
    borderStyle: 'white',
    list: [
      {
        pagePath: 'pages/index/index',
        iconPath: 'static/images/icon-homeed.png',
        selectedIconPath: 'static/images/icon-home.png',
        text: '首页'
      },
      {
        pagePath: 'pages/task/task',
        iconPath: 'static/images/icon-tasked.png',
        selectedIconPath: 'static/images/icon-task.png',
        text: '任务'
      },
      {
        pagePath: 'pages/my/my',
        iconPath: 'static/images/icon-myed.png',
        selectedIconPath: 'static/images/icon-my.png',
        text: '我的'
      }
    ]
  }
}
```

这里面都是根据官方的配置去写即可了。因为这部分内容不多，因此没有必要拆分。区别就是，这里是JS，所以不用写双引号~呵呵。。。

### 编写 modules 下子路由文件

上代码：

```
module.exports = {
  baseUrl: 'pages/small/',
  children: [
    {
      path: 'register',
      name: '注册'
    }, {
      path: 'login',
      name: '登录'
    }
  ]
}
```

导出一个对象，其中 `baseUrl` 是指你这些文件存放的位置目录。拆分出来的原因是不想在每个页面的路径里都要写这些重复的代码。

`children` 中就是该子路由涵盖的各个页面的路径以及标题了。

> 这里和 `uniapp` 默认的 `pages.json` 中的格式略有区别，我在 `build.js` 文件里面的 `buildRouter()` 函数就是做这个数据格式转化的。目的是为了让我们的子路由配置代码更加简洁。

这里需要注意的是，如果你需要使用到其他的配置项，就直接写就可以了。原来啥格式就是啥格式，比如这样：

```
module.exports = {
  baseUrl: 'pages/small/',
  children: [
    {
      path: 'register',
      name: '注册',
      'app-plus': {
        titleNView: {
          buttons: [
            {
              text: '消息',
              fontSize: '16px'
            }
          ]
        }
      }
    }, {
      path: 'login',
      name: '登录'
    }
  ]
}
```

上面的这个 `'app-plus'` 会自动插入进去的，官方文档要求怎么写，你在这边就怎么写就好了。一般这个用得比较少，所以这个我就不做额外的处理了。

## 使用

构建好这些代码之后，直接在命令行中运行 `node router/build.js` 就会在项目根目录中生成 `pages.json` 文件了。

> 这里需要说明的是，我这边项目是使用 `hbuilder` GUI界面生成的项目，所以根目录就是项目根目录。**如果是使用的 CLI 工具生成的项目，上文中的根目录就变成了项目的** `src` **目录。**

如果想直接下载代码，可以看我的仓库 https://github.com/fengcms/uniapp-pages-json-cli-build 如果去 github 下载的话，给我点个赞哦！

## Copyright and License

Copyright by FungLeo(web@fengcms.com)

License: MIT21:T5df,
![](http://developers-center.oss-cn-beijing.aliyuncs.com/js-logo.png)

## file对象转base64

```js
  let reader = new FileReader();
  reader.readAsDataURL(file[0])
  console.log(reader)
```

## base64 转成blob 上传

```js
function dataURItoBlob(dataURI) {  
    var byteString = atob(dataURI.split(',')[1]);  
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];  
    var ab = new ArrayBuffer(byteString.length);  
    var ia = new Uint8Array(ab);  
    for (var i = 0; i < byteString.length; i++) {  
        ia[i] = byteString.charCodeAt(i);  
    }  
    return new Blob([ab], {type: mimeString});  
}
```

## blob 转成ArrayBuffer

```js
let blob = new Blob([1,2,3,4])
let reader = new FileReader();
reader.onload = function(result) {
    console.log(result);
}
reader.readAsArrayBuffer(blob);
```

## buffer 转成blob

```js
let blob = new Blob([buffer])
```

## base64 转 file

```js
const base64ConvertFile = function (urlData, filename) { // 64转file
  if (typeof urlData != 'string') {
    this.$toast("urlData不是字符串")
    return;
  }
  var arr = urlData.split(',')
  var type = arr[0].match(/:(.*?);/)[1]
  var fileExt = type.split('/')[1]
  var bstr = atob(arr[1])
  var n = bstr.length
  var u8arr = new Uint8Array(n)
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new File([u8arr], 'filename.' + fileExt, {
    type: type
  });
}
```
## 介绍

> Web Api 接口参考 [File](https://developer.mozilla.org/zh-CN/docs/Web/API/File)

> 22:T600,![](http://developers-center.oss-cn-beijing.aliyuncs.com/image.png)
 
 vue2 中使用 swiper 插件的一些记录

### 安装

```
npm install swiper@6 vue-awesome-swiper@4 --save
```

### 全局注册

```js
import Vue from 'vue'
import VueAwesomeSwiper from 'vue-awesome-swiper'
 
// import style (>= Swiper 5.x)
import 'swiper/css/swiper.css';
// import style (>= Swiper 6.x)
import 'swiper/swiper-bundle.css'
 
Vue.use(VueAwesomeSwiper, /* { default options with global component } */)
```

### 使用

```html
<swiper ref="mySwiper" :options="swiperOptions">
    <swiper-slide>Slide 1</swiper-slide>
    <swiper-slide>Slide 2</swiper-slide>
    <swiper-slide>Slide 3</swiper-slide>
    <swiper-slide>Slide 4</swiper-slide>
    <swiper-slide>Slide 5</swiper-slide>
    <div class="swiper-pagination" slot="pagination"></div>
  </swiper>
```
```js
swiperOptions: {
  slidesPerView: 4,//显示个数
  direction: 'vertical',
   pagination: {
      el: '.swiper-pagination'
   },
}
```
```js
computed: {
   swiper() {
      return this.$refs.mySwiper.swiper
   }
},
 mounted() {
    this.swiper.slideTo(3, 1000, false)
 }
```

### 配置

根据具体情况自行配置，具体参考 [swiper中文文档](https://www.swiper.com.cn/api/index.html)

data中设置参数
```js
swiperOption: {
  loop: true,
  autoplay: {
    delay: 3000,
    disableOnInteraction: false,
  },
}
```

部分配置无效需引入相关依赖(ps: 如autoplay， effetcs)

```js
import SwiperCore, { Autoplay } from 'swiper';
SwiperCore.use([Autoplay]);
```23:T5ec,![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eff5ab7f7c349cb945fd235ca909abc~tplv-k3u1fbpfcp-zoom-1.image)

###  查看所有配置
```
git config --list
```
### 查看当前项目配置的 git 用户

在项目目录下输入

```
git config user.name	// 当前项目git用户名
git config user.email	// 当前项目git用户邮箱
```

### 设置当前项目的 git 用户

```
git config user.name myName	// 自己的用户名
git config user.email myEmail	// 自己的邮箱
git config --list	// 查看当前项目的git配置信息（会先列出全局配置，最下面列出的是当前项目的配置）
```
在当前项目下面查看的配置是全局配置 + 当前项目的配置, 使用的时候会优先使用当前项目的配置。
也可以直接在项目的根目录里的 .git 文件夹里，打开 config 文件查看当前项目的 git 配置信息：

```
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[submodule]
	active = .
[remote "origin"]
	url = https://github.com/DawnYu9/Test.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master

```

在最后面添加该项目的用户信息：

```
[user]
	name = myName
	email = myEmail
```

### 设置全局的 git 用户

```
git config --global user.name globalName	// 全局的用户名
git config --global user.email globalEmail	// 全局的邮箱
git config --list	// 查看配置信息
```24:T52b,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_static_assets_rpm6.svg)

## 方案1：如果不是想设置为透明色 可直接使用 [box-shadow](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow)

```
input:-webkit-autofill{
	-webkit-box-shadow:0 0 0 1000px white inset !important;
}
```

## 方案2：关闭自动填充功能 ( 也可实现 不推荐 )

```
<input type="text" autocomplete="off">
```

## 方案3：通过CSS3动画解决

```
input:-webkit-autofill,
    input:-webkit-autofill:hover,
    input:-webkit-autofill:focus,
    input:-webkit-autofill:active {
        -webkit-transition-delay: 111111s;
        -webkit-transition: color 11111s ease-out, background-color 111111s ease-out;
    } 
```

## 代码示例

```

    .entername>.el-input__inner{
        border: none;
        line-height: 38px;
        padding-left: 10px;
        padding-right: 0;
        background: transparent; 
        color:#ccc
    } 
     .entername>.el-input__inner:-webkit-autofill,
     .entername>.el-input__inner:-webkit-autofill:hover,
     .entername>.el-input__inner:-webkit-autofill:focus,
     .entername>.el-input__inner:-webkit-autofill:active {
        -webkit-transition-delay: 99999s;
        -webkit-transition: color 99999s ease-out, background-color 99999s ease-out;
    }  
```25:T16e6,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_next_js_-8-g5m.7d2e18ea.svg)

## 添加 Google AdSense

将Google AdSense客户端ID添加为环境变量。

.env.local
```
NEXT_PUBLIC_GOOGLE_ADSENSE=ca-pub-5674178816323888
```
然后，在_document.tsx中添加以下内容。 这样，Google AdSense加载一旦您的下一个应用程序安装。<script> <head>
```javascript
<script
  async
  src={`https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${process.env.NEXT_PUBLIC_GOOGLE_ADSENSE}`}
  crossOrigin="anonymous"
/>
```
在AdSense控制台中，创建一个新的广告单元。 您将被要求复制一些看起来这样的代码。 不要复制它。 这是反应将进入的地方。
```javascript
<script
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5674178816323888"
  crossorigin="anonymous"
></script>
<!-- responsive -->
<ins
  class="adsbygoogle"
  style="display:block"
  data-ad-client="ca-pub-5674178816323888"
  data-ad-slot="7181773959"
  data-ad-format="auto"
  data-full-width-responsive="true"
></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>
```

## 创建Google Adsense AD React组件
本文其余部分中的信息适用于您是否使用Next.js，gatsby.js，Create React App 或 custom react setup。

灵感来自这个 [GitHub comment](https://github.com/vercel/next.js/discussions/14395#discussioncomment-28847) ，创建一个组件来封装您的Google广告。

components/GoogleAd.tsx

```typescript
import {useEffect} from 'react';

export function GoogleAd() {
  useEffect(() => {
    try {
      // @ts-ignore
      (window.adsbygoogle = window.adsbygoogle || []).push({});
    } catch (err) {
      console.error(err);
    }
  }, []);

  return (
    <ins
      className="adsbygoogle"
      style={{display: 'block'}}
      data-ad-client={process.env.NEXT_PUBLIC_GOOGLE_ADSENSE}
      data-ad-slot="7181773959"
      data-ad-format="auto"
      data-full-width-responsive="true"
    />
  );
}
```

现在，您可以放置Google广告在任何您想要的地方。

## Supporting Multiple Ad Unit Types
Define an for each ad unit you define. For example,enum

components/GoogleAd.tsx

```
export enum AdType {
  DEFAULT,
  ARTICLE,
  VERTICAL,
}
```

然后，设置将每个广告单元映射到其相应的props.Record

components/GoogleAd.tsx

```typescript
const adUnitProps: Record<AdType, any> = {
  [AdType.DEFAULT]: {
    'data-ad-slot': '7181773959',
    'data-ad-format': 'auto',
    'data-full-width-responsive': 'true',
  },
  [AdType.ARTICLE]: {
    'data-ad-slot': '3197857275',
    'data-ad-format': 'fluid',
    'data-ad-layout': 'in-article',
  },
  [AdType.VERTICAL]: {
    'data-ad-slot': '8863578035',
    'data-ad-format': 'auto',
    'data-full-width-responsive': 'true',
  },
};
```

修改您的组件以接受Prop.GoogleAdtype

components/GoogleAd.tsx
```typescript
import {useEffect} from 'react';

interface GoogleAdProps {
  variant?: AdType;
}

export function GoogleAd({variant = AdType.DEFAULT}: GoogleAdProps) {
  useEffect(() => {
    try {
      // @ts-ignore
      (window.adsbygoogle = window.adsbygoogle || []).push({});
    } catch (err) {
      console.error(err);
    }
  }, []);

  return (
    <ins
      className="adsbygoogle"
      style={{display: 'block'}}
      data-ad-client={process.env.NEXT_PUBLIC_GOOGLE_ADSENSE}
      {...adUnitProps[variant]}
    />
  );
}
```
现在，您应该能够在您的Next.js网站上使用Google AdSense广告。

## Fixing Overflow with Adsense Ads
Sometimes the ads can overflow when resizing the viewport.

Here's what it could look like.

Main Content

Ad

Following Google's advice on overflow issues, we'll hide the overflow content.

components/GoogleAd.tsx
```
<div style={{overflow: 'hidden'}}>
  <ins
    className="adsbygoogle"
    style={{display: 'block'}}
    data-ad-client={process.env.NEXT_PUBLIC_GOOGLE_ADSENSE}
    {...adUnitProps[variant]}
  />
</div>
```
Setting might cut off part of your ad when the viewport's resized. But at least the ad won't break your site's layout if the viewport shrinks.overflow: 'hidden'

Here's what it looks like when you set .overflow: 'hidden'

Main Content

Ad

## Preventing Cumulative Layout Shift with Google Adsense
Cumulative Layout Shift (CLP) occurs when the ad pushes your content out of the way after loading. CLP will hurt your Lighthouse score and SEO.

To minimize layout shift, preemptively set a height and width to make room for your ad.

components/GoogleAd.tsx
```
<div style={{overflow: 'hidden', minWidth: '300px', minHeight: '250px'}}>
  <ins
    className="adsbygoogle"
    style={{display: 'block'}}
    data-ad-client={process.env.NEXT_PUBLIC_GOOGLE_ADSENSE}
    {...adUnitProps[variant]}
  />
</div>
```
## Remove Ads from Assistive Technologies like Screen Readers
The problem with Google Adsense ads is you inject an containing the advertisers content and markup on your site. Then, when you run a Lighthouse check on your site, the advertiser's problems become your problem. If the ad contains bad HTML decisions, you will get dinged for it.<iframe>

Let's address this by hiding the aria contained by the ad. It doesn't make sense to expose an ad to assistive technologies like screen readers anyway. But you should do your own testing and see if it makes sense to follow this advice for your own business.

If you make this change, then your Lighthouse score won't be affected by any crap the advertiser puts in their markup.
```
<div
  aria-hidden={true}
  style={{overflow: 'hidden', minWidth: '300px', minHeight: '250px'}}
>
  <ins
    className="adsbygoogle"
    style={{display: 'block'}}
    data-ad-client={process.env.NEXT_PUBLIC_GOOGLE_ADSENSE}
    {...adUnitProps[variant]}
  />
</div>
```
Hope this info helps you prosper. 💸26:T2f25,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_react_y-7-wq.1ac05cd7.svg)

## 前言

在学习任何一个框架原理之前，学习它的生命周期是非常必要的，至少可以让我们明白在什么时候该做什么事情。不至于犯一些低级错误。

`React 16.8` 版本正式发布了 `Hook` 机制，因此本文会分别讲解 `Class Component` 生命周期与 `Function Component` 生命周期。

## Class Component 生命周期

React 生命周期指的是组件从创建到卸载的整个过程，每个过程都有对应的钩子函数会被调用，它主要有以下几个阶段：

-   挂载阶段  -  组件实例被创建和插入 DOM 树的过程
-   更新阶段  -  组件被重新渲染的过程
-   卸载阶段  -  组件从 DOM 树中被删除的过程

### 挂载阶段

这个阶段是做初始化操作，主要有这几个钩子函数：

#### static defaultProps

设置 props 的默认值

```
static defaultProps = {
  name: '子组件设置的默认props'
}
```

#### static propTypes 

props 数据类型检查

```
import PropTypes from 'prop-types';

static propsTypes = {
  name: PropTypes.string // 限定name为string类型
}
```

#### constructor(props) 

构造函数的作用：

-   初始化 `props and state`
-   绑定事件处理函数

```
constructor(props) {
  super(props);
  this.state = {number: 0};
  this.handlexxx = this.handlexxx.bind(this)
}
```

#### componentWillMount() 

组件挂载前钩子**(17版本后不推荐使用)**

由于 React 未来的版本中推出了异步渲染，DOM 被挂载之前的阶段都可以被打断重来，导致 `componentWillMount` 、 `componentWillUpdate` 、 `componentWillReceiveProps` 在一次更新中可能会被触发多次，因此那些只希望触发一次的副作用应该放在 `componentDidMount` 中。

这也就是为什么要把异步请求放在 `componentDidMount` 中，而不是放在 `componentWillMount` 中的原因，是为了向后兼容。

```
componentWillMount() {
	// componentWillMount在渲染过程中可能会执行多次
}
```

#### componentDidMount() 

组件挂载成功钩子，该过程组件已经成功挂载到了真实 DOM 上。

由于在渲染过程中只执行一次，因此常用来：

-   监听事件；
-   获取到真实 DOM；
-   请求后台接口。

```
componentDidMount(){
  fetch('https://api.github.com/users').then(res=>res.json()).then(users=>{
    console.log(users);
    this.setState({users});
  });
}
```

### 更新阶段

这个阶段主要是做状态更新操作，主要有这几个钩子函数：

#### componentWillReceiveProps(newProps) 

父组件更新 props 钩子**(17版本后不推荐使用)**

#### shouldComponentUpdate(nextProps, nextState)  

组件是否更新钩子

由于 React 父组件更新，必然会导致子组件更新，因此我们可以在子组件中通过手动对比 `props` 与 `nextProps`，`state` 与 `nextState` 来确定是否需要重新渲染子组件，如果需要则返回`true`，不需要则返回 `false`。该函数默认返回 `true`。

```
 shouldComponentUpdate(nextProps, nextState) {
   console.log('Counter', nextProps, nextState);
   console.log('5. shouldComponentUpdate 询问组件是否需要更新');
   return true;
 }
```

#### componentWillUpdate()

组件更新前钩子**(17版本后不推荐使用)**

#### componentDidUpdate() 

此生命周期方法在组件更新完后被调用。

-   因为组件已经重新渲染了所以这里可以对组件中的 DOM 进行操作；
-   在比较了 `this.props` 和 `nextProps` 的前提下可以发送网络请求。

```
componentDidUpdate(prevProps, prevState, snapshot) {
	if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
```

### 卸载阶段

这个阶段主要是从 DOM 树中删除组件的操作，它的钩子只有一个 `componentWillUnmount` 。

#### componentWillUnmount() 

这是 `unmount` 阶段唯一的生命周期，在这里进行的是善后工作：清理计时器、取消网络请求或者取消事件监听等。


### 17版本生命周期

新增了两个生命周期函数：

1.  `static getDerivedStateFromProps(nextProps, prevState)`
1.  `getSnapshotBeforeUpdate(prevProps, prevState)`

删除了以下生命周期函数：

1.  `componentWillMount`
1.  `componentWillReceiveProps`
1.  `componentWillUpdate`

从这个版本开始，只有新的 `UNSAFE_` 生命周期名称将起作用：

1.  `UNSAFE_componentWillMount`
1.  `UNSAFE_componentWillReceiveProps`
1.  `UNSAFE_componentWillUpdate`

#### static getDerivedStateFromProps(nextProps, prevState)

在 `render` 前调用，在初始挂载以及后续更新时都会被调用。

他应该返回一个对象来更新 `state`。如果返回 `null` 则不更新任何内容。

它接收两个参数，一个是传进来的 `nextProps` 和之前的 `prevState`。

```
static getDerivedStateFromProps(nextProps, prevState){
  console.log('getDerivedStateFromProps',nextProps,prevState);
  return null;
}
```

#### getSnapshotBeforeUpdate(prevProps, prevState)

在更新阶段 render 后挂载到真实 DOM 前进行的操作，它使得组件能在发生更改之前从 DOM 中捕获一些信息。此组件返回的任何值将作为 `componentDidUpdate` 的第三个参数。

```
  getSnapshotBeforeUpdate(prevProps, prevState){
    return "getSnapshotBeforeUpdate";
  }

  // 组件更新成功钩子
  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log(snapshot); // "getSnapshotBeforeUpdate"
  }
```

[生命周期网站查询链接](https://link.juejin.cn?target=https%3A%2F%2Fprojects.wojtekmaj.pl%2Freact-lifecycle-methods-diagram%2F "https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/")

以上就是 Class 组件的生命周期函数以及使用方法，然而不论 Class 组件多好用，我们已经拥抱Hooks。

## Function Component 生命周期

`Function Component` 是更彻底的状态驱动抽象，甚至没有 `Class Component` 生命周期的概念，只有一个状态，而 React 负责同步到 DOM。

回顾下在 `Class Component` 的数据请求：

1.  在 `componentDidMount` 初始化发请求；
1.  在 `componentDidUpdate` 判断参数是否变化，变化就调用请求函数重新请求数据；
1.  在 `componentWillUnmount` 生命周期取消发送请求。

那么在函数组件中我们该如何做呢？答案是 `useEffect` 。

### useEffect

`useEffect` 就是一个 `Effect Hook` ，给函数组件增加了操作副作用的能力。它跟 class 组件中的 `componentDidMount` 、 `componentDidUpdate`  和 `componentWillUnmount` 具有相同的用途，只不过被合并成了一个 API。

**useEffect 做了什么：**

-   使用 `useEffect` 相当于告诉 React 组件需要在渲染后执行某些操作，React 将在执行 DOM 更新之后调用它。
-   React 保证了每次运行 `useEffect` 的时候，DOM 已经更新完毕。

Class 组件 Demo：

```
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }
  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
```

Function Component 重写该案例：

```
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // 相当于 componentDidMount 和 componentDidUpdate:
  useEffect(() => {
    // 使用浏览器的 API 更新页面标题
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

### 需要清除的 effect

在 class 组件中，我们去监听原生 DOM 事件时，会在 `componentDidMount` 这个生命周期中去做，因为在这里可以获取到已经挂载的真实 DOM。我们也会在组件卸载的时候去取消事件监听避免内存泄露。那么在 `useEffect` 中该如何实现呢？

```
useEffect(() => {
  function handleClick(status) {
    document.title = `You clicked ${count} times`;
  }
  
  document.body.addEventListener("click",handleClick,false);
 
  return function cleanup() {
    document.body.removeEventListener("click",handleClick,false);
  };
});
```

通过在 `useEffect` 中返回一个函数，它便可以清理副作用。

清理规则是：

-   **首次渲染不会进行清理，会在下一次渲染，清除上一次的副作用；**
-   **卸载阶段也会执行清除操作。**

### Dependencies

在 `useEffect` 中我们会去请求后台数据，通过前面的学习我们也了解到每次更新组件时我们都会再次去执行 `useEffect` ，但其实我们并不需要每次更新组件都发送请求。那么碰到这样的问题如何处理呢？

回顾上面是不是类似于 `componentDidUpdate` 中发送请求呢？直觉是对的，在`componentDidUpdate` 中我们是通过判断参数是否变化来避免每次都发送请求，那么在 `useEffect hook` 中我们也是异曲同工，通过第二个参数是否发生变换来决定是否重复执行，如果第二参数为空数组，则表示只在初始化执行一次，后续更新不会再次调用。

```
useEffect(() => {
  fetchData(instanceId){...}
  
  fetchData(instanceId);
}, [instanceId]);
```

上面例子是通过 `fetchData` 函数去请求后台数据，具体函数体我们就省略了，然后你会发现`useEffect` 的第二个参数添加了一个数组，其中添加了一个参数 `instanceId`，它表示只有当`instanceId` 变化时，我们才去再次执行 `useEffect`。这样就可以避免我们多次请求后台数据。

当然我们的依赖项还可以传入一个空数组，就表示只在初始化时执行一次：

```
useEffect(() => {
  fetchData(instanceId){...}
  
  fetchData(instanceId);
}, []);
```

### useCallback

```
const memoizedCallback = useCallback(
  () => {
    doSomething(a);
  },
  [a],
);
```

把内联回调函数及依赖项数组作为参数传入 `useCallback` ，它将返回该回调函数的 `memoized` 版本，该回调函数仅在某个依赖项改变时才会更新。

通俗来讲当参数 a 发生变化时，会返回一个新的函数引用赋值给 `memoizedCallback` 变量，因此这个变量就可以当做 `useEffect` 第二个参数。这样就有效的将逻辑分离出来。

```
function Parent(){
	const [query,setQuery] = useState('q');
  const fetchData = useCallback(()=>{
  	...省略函数体的具体实现
  },[query]);
  return <Child fetchData={fetchData} />
}
  
function Child({fetchData}){
  const [data,setData] = useState(null);
	useEffect(()=>{
  	fetchData().then(setData);
  },[fetchData])
}
```

经过 `useCallback` 包装过的函数可以当作普通变量作为 `useEffect` 的依赖。 `useCallback`做的事情，就是在其依赖变化时，返回一个新的函数引用，触发 `useEffect` 的依赖变化，并激活其重新执行。

现在我们不需要在 `useEffect` 依赖中直接对比 `query` 参数了，而可以直接对比 `fetchData` 函数。useEffect 只要关心 `fetchData` 函数是否变化，而 `fetchData` 参数的变化在 `useCallback` 时关心，能做到 依赖不丢、逻辑内聚，从而容易维护。

## 小结

本文通过讲解 `Class Component` 与 `Function Component`分别的生命周期函数，让我们可以更加深入的理解 React 的运行原理。并且生命周期也是面试中常见问题，因此我们需要熟练掌握。

作者：Lion
链接：https://juejin.cn/post/6871728918643081230
来源：稀土掘金27:T165f,**前言**

在没有封装插件之前，如果不使用第三方插件，那么很多情况下我们会编写几个常用的组件来提供给页面使用，如Alert/Loading组件，而你可能需要在很多页面中引入并且通过components注册组件，但是像这样使用率很高的组件一般我们希望全局注册后直接就可以在相应页面使用，因此我们需要将他们封装成插件，这里我们编写一个toast全局提示插件来作个简单的介绍

**插件**

```
插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：

1.添加全局方法或者 property。

2.添加全局资源：指令/过滤器/过渡等。

3.通过全局混入来添加一些组件选项。

4.添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。

5.一个库，提供自己的 API，同时提供上面提到的一个或多个功能。
```

vue插件的编写方法一般分为以上5类，其注册与绑定机制如下：

```
export default {
    install(Vue, options) {
        Vue.myGlobalMethod = function () {  // 1. 添加全局方法或属性，如:  vue-custom-element
            // 逻辑...
        }
        Vue.directive('my-directive', {  // 2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch
            bind (el, binding, vnode, oldVnode) {
                // 逻辑...
            }
            ...
        })
        Vue.mixin({
            created: function () {  // 3. 通过全局 mixin方法添加一些组件选项，如: vuex
                // 逻辑...
            }
            ...
        })
        Vue.prototype.$myMethod = function (options) {  // 4. 添加实例方法，通过把它们添加到 Vue.prototype 上实现
            // 逻辑...
        }
    }
}
```

\
上方代码使用了es6部分语法列出了4种编写插件的方法，而install是注册插件主要调用的方法，包含了两个参数（Vue实例和自定义配置属性options）

**开发插件**

我们这里主要使用的是第四种方法，将我们的插件函数注册到Vue.prototype实例上面\
首先我们在plugin里创建个toast文件夹用来放置插件,里面包含两个文件，toast.vue和toast.js，

\


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3762e7487fa745d5a732f5e9697196ee~tplv-k3u1fbpfcp-zoom-1.image)

\


然后在编写我们的样式结构文件toast.vue

这里我们使用了一个visible变量来控制提示框的显示，message为提示的消息

```
<template>
      <div v-if="visible">
          <div>{{message}}</div>
      </div>
</template>
<script>
export default {
  data() {
    return {
      visible: false,
      message: ""
    };
  }
};
</script>
```

\
接着在toast.js里面编写插件的方法与处理函数

```
import ToastComponent from './toast.vue'    //引入toast.vue组件

export default {    // 导出一个对象，里面包含vue注册插件所调用的方法install
    install: function (Vue) {
        const ToastConstructor = Vue.extend(ToastComponent)    // 将toast.vue组件生成为Vue的子类
        const instance = new ToastConstructor();    // 生成一个该子类的实例

        instance.$mount(document.createElement('div'))    // 将这个实例挂载在新创建的div上，并加入到body中
        document.body.appendChild(instance.$el)

        // 通过Vue的原型注册一个方法$toast，有两个参数（msg为提示的文字，duration为延时关闭）
        Vue.prototype.$toast = (msg, duration = 1500) => {
            if (instance.visible) return;    // visible是toast.vue组件的一个变量，用来控制提示框的显示

            instance.message = msg;
            instance.visible = true;

            setTimeout(() => {    // 默认延时1.5s关闭提示框
                instance.visible = false;
            }, duration);
        }
    }
}
```

\
这样我们就完成了组件的封装，是不是很简单

**使用插件**

现在把我们封装好的插件引入到main.js中

```
import toast from './plugin/toast'
Vue.use(toast);
```

\
然后我们就可以在组件中使用它了

```
this.$toast('提示文字')
```

我们现在把toast.vue添加上样式和过度效果，让它看起来更加的友好，以下是toast.vue文件的全部内容

```
<template>
   <!-- 全局提示框 -->
   <transition name="slide-fade">
      <div v-if="visible" class="dialog-tips">
          <div>{{message}}</div>
      </div>
  </transition>
</template>
<script>
export default {
  data() {
    return {
      visible: false,
      message: ""
    };
  }
};
</script>
<style scoped>
.dialog-tips{
    min-width: 380px;
    box-sizing: border-box;
    border-radius: 4px;
    border: 1px solid #e1f3d8;
    position: fixed;
    left: 50%;
    top: 20px;
    transform: translateX(-50%);
    background-color: #f0f9eb;
    overflow: hidden;
    padding: 15px 15px 15px 20px;
    display: flex;
    align-items: center;
    color: #67c23a;
}

.slide-fade-enter, .slide-fade-leave-to {
  margin-top:-30px;
  opacity: 0;

}

.slide-fade-enter-active,.slide-fade-leave-active {
  transition: all .3s ease;
}

.slide-fade-enter-to,.slide-fade-leave {
  margin-top:0px;
  opacity:1;
}
</style>
```

\
让我们来看看效果

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6174dcccd564c12ac1a757c04726898~tplv-k3u1fbpfcp-zoom-1.image)

\


**结语**

以上我们就实现了一个简单的toast插件，开发插件的方式和插件的类型有很多种，这里只是介绍了其中的一种方式，帮助大家了解在编写插件的过程中所用到的方法，大家也可以使用其它方法来去开发不同类型的插件。28:T1e17,![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_static_assets_rpm6.svg)

不是标题党，这是一位leader在一次代码评审会对小组成员发出的“怒吼”，原因是在代码评审中发现很多地方还是采用ES5的写法，也不是说用ES5写法不行，会有BUG，只是造成代码量增多，可读性变差而已。

恰好，这位leader有代码洁癖，面对3~5年经验的成员，还写这种水平的代码，极为不满，不断对代码进行吐槽。不过对于他的吐槽，我感觉还是有很大收获的，故就把leader的吐槽记录下来，分享给掘友们，觉得有收获点个赞，有错误的或者更好的写法，非常欢迎在评论中留言。

**ps：ES5之后的JS语法统称ES6！！！**

## 一、关于取值的吐槽

取值在程序中非常常见，比如从对象`obj`中取值。

```
const obj = {
    a:1,
    b:2,
    c:3,
    d:4,
    e:5,
}
```

**吐槽**：

```
const a = obj.a;
const b = obj.b;
const c = obj.c;
const d = obj.d;
const e = obj.e;
```

或者

```
const f = obj.a + obj.d;
const g = obj.c + obj.e;
```

吐槽：“不会用ES6的解构赋值来取值吗？5行代码用1行代码搞定不香吗？直接用对象名加属性名去取值，要是对象名短还好，很长呢？搞得代码中到处都是这个对象名。”

**改进**：

```
const {a,b,c,d,e} = obj;
const f = a + d;
const g = c + e;
```

**反驳**

不是不用ES6的解构赋值，而是服务端返回的数据对象中的属性名不是我想要的，这样取值，不是还得重新创建个遍历赋值。

**吐槽**

看来你对ES6的解构赋值掌握的还是不够彻底。如果想创建的变量名和对象的属性名不一致，可以这么写：

```
const {a:a1} = obj;
console.log(a1);// 1
```

**补充**

ES6的解构赋值虽然好用。但是要注意解构的对象不能为`undefined`、`null`。否则会报错，故要给被解构的对象一个默认值。

```
const {a,b,c,d,e} = obj || {};
```

## 二、关于合并数据的吐槽

比如合并两个数组，合并两个对象。

```
const a = [1,2,3];
const b = [1,5,6];
const c = a.concat(b);//[1,2,3,1,5,6]

const obj1 = {
  a:1,
}
const obj2 = {
  b:1,
}
const obj = Object.assign({}, obj1, obj2);//{a:1,b:1}
```

**吐槽**

ES6的扩展运算符是不是忘记了，还有数组的合并不考虑去重吗？

**改进**

```
const a = [1,2,3];
const b = [1,5,6];
const c = [...new Set([...a,...b])];//[1,2,3,5,6]

const obj1 = {
  a:1,
}
const obj2 = {
  b:1,
}
const obj = {...obj1,...obj2};//{a:1,b:1}
```

## 三、关于拼接字符串的吐槽

```
const name = '小明';
const score = 59;
let result = '';
if(score > 60){
  result = `${name}的考试成绩及格`; 
}else{
  result = `${name}的考试成绩不及格`; 
}
```

**吐槽**

像你们这样用ES6字符串模板，还不如不用，你们根本不清楚在`${}`中可以做什么操作。在`${}`中可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。

**改进**

```
const name = '小明';
const score = 59;
const result = `${name}${score > 60?'的考试成绩及格':'的考试成绩不及格'}`;
```

## 四、关于if中判断条件的吐槽

```
if(
    type == 1 ||
    type == 2 ||
    type == 3 ||
    type == 4 ||
){
   //...
}
```

**吐槽**

ES6中数组实例方法`includes`会不会使用呢？

**改进**

```
const condition = [1,2,3,4];

if( condition.includes(type) ){
   //...
}
```

## 五、关于列表搜索的吐槽

在项目中，一些没分页的列表的搜索功能由前端来实现，搜索一般分为精确搜索和模糊搜索。搜索也要叫过滤，一般用`filter`来实现。

```
const a = [1,2,3,4,5];
const result = a.filter( 
  item =>{
    return item === 3
  }
)
```

**吐槽**

如果是精确搜索不会用ES6中的`find`吗？性能优化懂么，`find`方法中找到符合条件的项，就不会继续遍历数组。

**改进**

```
const a = [1,2,3,4,5];
const result = a.find( 
  item =>{
    return item === 3
  }
)
```

## 六、关于扁平化数组的吐槽

一个部门JSON数据中，属性名是部门id，属性值是个部门成员id数组集合，现在要把有部门的成员id都提取到一个数组集合中。

```
const deps = {
'采购部':[1,2,3],
'人事部':[5,8,12],
'行政部':[5,14,79],
'运输部':[3,64,105],
}
let member = [];
for (let item in deps){
    const value = deps[item];
    if(Array.isArray(value)){
        member = [...member,...value]
    }
}
member = [...new Set(member)]
```

**吐槽**

获取对象的全部属性值还要遍历吗？`Object.values`忘记了吗？还有涉及到数组的扁平化处理，为啥不用ES6提供的`flat`方法呢，还好这次的数组的深度最多只到2维，还要是遇到4维、5维深度的数组，是不是得循环嵌套循环来扁平化？

**改进**

```
const deps = {
    '采购部':[1,2,3],
    '人事部':[5,8,12],
    '行政部':[5,14,79],
    '运输部':[3,64,105],
}
let member = Object.values(deps).flat(Infinity);
```

其中使用`Infinity`作为`flat`的参数，使得无需知道被扁平化的数组的维度。

**补充**

`flat`方法不支持IE浏览器。

## 七、关于获取对象属性值的吐槽

```
const name = obj && obj.name;
```

**吐槽**

ES6中的可选链操作符会使用么？

**改进**

```
const name = obj?.name;
```

## 八、关于添加对象属性的吐槽

当给对象添加属性时，如果属性名是动态变化的，该怎么处理。

```
let obj = {};
let index = 1;
let key = `topic${index}`;
obj[key] = '话题内容';
```

**吐槽**

为何要额外创建一个变量。不知道ES6中的对象属性名是可以用表达式吗？

**改进**

```
let obj = {};
let index = 1;
obj[`topic${index}`] = '话题内容';
```

## 九、关于输入框非空的判断

在处理输入框相关业务时，往往会判断输入框未输入值的场景。

```
if(value !== null && value !== undefined && value !== ''){
    //...
}
```

**吐槽**

ES6中新出的空值合并运算符了解过吗，要写那么多条件吗？

```
if((value??'') !== ''){
  //...
}
```

## 十、关于异步函数的吐槽

异步函数很常见，经常是用 Promise 来实现。

```
const fn1 = () =>{
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(1);
    }, 300);
  });
}
const fn2 = () =>{
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(2);
    }, 600);
  });
}
const fn = () =>{
   fn1().then(res1 =>{
      console.log(res1);// 1
      fn2().then(res2 =>{
        console.log(res2)
      })
   })
}
```

**吐槽**

如果这样调用异步函数，不怕形成地狱回调啊！

**改进**

```
const fn = async () =>{
  const res1 = await fn1();
  const res2 = await fn2();
  console.log(res1);// 1
  console.log(res2);// 2
}
```

**补充**

但是要做并发请求时，还是要用到`Promise.all()`。

```
const fn = () =>{
   Promise.all([fn1(),fn2()]).then(res =>{
       console.log(res);// [1,2]
   }) 
}
```

如果并发请求时，只要其中一个异步函数处理完成，就返回结果，要用到`Promise.race()`。

## 十一、后续

欢迎来对以上十点leader的吐槽进行反驳，你的反驳如果有道理的，下次代码评审会上，我替你反驳。

此外以上的整理内容有误的地方，欢迎在评论中指正，万分感谢。

如果你还有其它想吐槽的，也非常欢迎在评论中留下你的吐槽。

读完有帮助，不妨关注一下，点个赞支持一下。

作者：红尘炼心\
链接：https://juejin.cn/post/7016520448204603423\
来源：稀土掘金9:["$","$Lb",null,{"blogs":[{"_id":"655e0fbe6dbb32cea912b236","title":"test2","pathName":"test2","markContent":"# 1111","viewCount":6,"createdAt":"2023-11-22T14:27:10.814Z","updatedAt":"2023-11-22T14:35:41.747Z","__v":0},{"_id":"655e07654fcec016231d6cfc","title":"test","markContent":"222","viewCount":4,"createdAt":"2023-11-22T13:51:33.388Z","updatedAt":"2023-11-22T14:36:46.710Z","__v":0},{"_id":"655cbbb94fcec016231d69e7","title":"使用Vue3实现大屏数字滚动效果的方法和技巧","markContent":"$c","viewCount":6,"createdAt":"2023-11-21T14:16:25.146Z","updatedAt":"2023-11-22T11:35:44.660Z","__v":0},{"_id":"655b7cdfd9abe650fa3b40f7","title":"get请求参数可以放在body中吗？ ","markContent":"$d","viewCount":88,"createTime":"2023-11-20T15:35:59.608Z","updateTime":"2023-11-20T21:50:26.178Z","createdAt":"2023-11-20T15:35:59.609Z","updatedAt":"2023-11-22T11:37:15.982Z","__v":0},{"_id":"6558c4aed9abe650fa3b3e50","title":"网站监控工具：免费监测网站是否正常运行","markContent":"$e","viewCount":16,"createTime":"2023-11-18T14:05:34.553Z","updateTime":"2023-11-18T14:05:34.553Z","createdAt":"2023-11-18T14:05:34.559Z","updatedAt":"2023-11-22T11:37:03.546Z","__v":0},{"_id":"6557439d7c2c3d24f343be13","title":"nvm-desktop：一款高效的 Node.js 版本可视化管理工具","markContent":"$f","viewCount":20,"createTime":"2023-11-17T10:42:37.549Z","updateTime":"2023-11-17T14:54:49.537Z","createdAt":"2023-11-17T10:42:37.554Z","updatedAt":"2023-11-22T11:35:02.574Z","__v":0},{"_id":"65551ceb3e780e3ef8d6b66f","title":"Vue的@input怎么做到不监听输入法拼音的？90%人不知道~","markContent":"$10","viewCount":122,"createTime":"2023-11-15T19:32:59.962Z","updateTime":"2023-11-16T18:43:02.777Z","__v":0,"createdAt":"2023-11-15T19:32:59.962Z","updatedAt":"2023-11-22T11:34:41.447Z"},{"_id":"64992c7b6aca61d0eb32c65f","title":"Docker常用命令行大全：快速掌握Docker常用操作","markContent":"## 在Linux上启动Docker\n\n```\nsudo systemctl start docker\n```\n\n## 在Linux上配置Docker开机自启动\n\n```\nsudo systemctl enable docker.service\n```","viewCount":568,"createTime":"2023-06-26T06:13:15.914Z","updateTime":"2023-06-26T06:22:52.972Z","__v":0,"createdAt":"2023-06-26T06:13:15.914Z","updatedAt":"2023-11-22T11:53:26.255Z"},{"_id":"63204271f4a469c3500cc11e","title":"Html input type number maxlength 属性失效解决方法","markContent":"$11","viewCount":1424,"createTime":"2022-09-13T08:42:25.392Z","updateTime":"2022-09-13T08:42:25.392Z","__v":0,"createdAt":"2022-09-13T08:42:25.392Z","updatedAt":"2023-11-22T13:58:00.323Z"},{"_id":"631c6745f4a469c3500cc037","title":"postcss 忽略文件夹及单个文件","markContent":"\n![](http://developers-center.oss-cn-beijing.aliyuncs.com/postcss.83d93145.svg)\n\n## 背景\n\n在使用 `vue` 开发项目的时候，我们使用 `postcss` 插件 `postcss-px-to-viewport` 对整个项目的 `px` 进行转换，但是在项目后期我们将原生老项目的 `html` 代码迁移到 `vue` 项目中，我们不需要对老项目的 `px` 进行转换，只需要对新项目的 `px` 进行转换，这时候我们就需要对 `postcss` 进行配置，让其忽略对老项目文件的转换。\n\n## 项目环境\n\n* ![](https://img.shields.io/badge/vite-^2.9.9-646cff)\n* ![](https://img.shields.io/badge/vue-^3.2.25-42b883)\n* ![](https://img.shields.io/badge/postcss--px--to--viewport-^1.1.1-dd3a0a)\n\n## Postcss 忽略属性 `exclude`\n\n只需要在 `postcss.config.js` 中配置 `exclude` 即可, `exclude` 是一个正则表达式数组( `exclude: [RegExp]` )，匹配的文件将不会被转换。\n\n## 忽略文件夹\n\n```\nexclude: [/node_modules/, /main/],\n```\n\n## 忽略单个文件\n\n```\nexclude: [/src\\/pages\\/index.vue/]\n```\n\n## 完整示例\n\n`postcss.config.js`\n\n```\nmodule.exports = {\n    plugins: {\n      'postcss-px-to-viewport': {\n        viewportWidth: 375,\n        unitPrecision: 6,\n        unitToConvert: 'px',\n        propList: ['*'],\n        exclude: [/node_modules/, /main/, /src\\/pages\\/index.vue/]\n      }\n    }\n}\n```","viewCount":1269,"createTime":"2022-09-10T10:30:29.048Z","updateTime":"2022-09-10T10:49:17.130Z","__v":0,"createdAt":"2022-09-10T10:30:29.048Z","updatedAt":"2023-11-22T11:45:04.630Z"},{"_id":"63198665f4a469c3500cbf3f","title":"axios x-www-form-urlencoded 请求","markContent":"$12","viewCount":1114,"createTime":"2022-09-08T06:06:29.385Z","updateTime":"2022-09-10T10:02:57.244Z","__v":0,"createdAt":"2022-09-08T06:06:29.385Z","updatedAt":"2023-11-22T11:42:50.492Z"},{"_id":"6318bb36f4a469c3500cbefe","title":"JS前端实现全屏和cancelFullscreen效果","markContent":"$13","viewCount":1052,"createTime":"2022-09-07T15:39:34.635Z","updateTime":"2022-09-07T15:39:34.635Z","__v":0,"createdAt":"2022-09-07T15:39:34.635Z","updatedAt":"2023-11-22T11:43:12.595Z"},{"_id":"6302f2b7fb839c1829f9d671","title":"利用vue-pdf实现pdf在线预览","markContent":"$14","viewCount":788,"createTime":"2022-08-22T03:06:31.992Z","updateTime":"2022-08-22T03:06:31.992Z","__v":0,"createdAt":"2022-08-22T03:06:31.992Z","updatedAt":"2023-11-22T11:38:10.326Z"},{"_id":"62c25d8ec97da52b249c7457","title":"Vue3 setup 基础及奇技淫巧","markContent":"$15","viewCount":710,"createTime":"2022-07-04T03:25:02.664Z","updateTime":"2022-08-31T07:20:38.649Z","__v":0,"createdAt":"2022-07-04T03:25:02.664Z","updatedAt":"2023-11-22T11:46:11.810Z"},{"_id":"62b52408a3b6a21ae059850b","title":"web(h5)  javascript 运行环境判断","markContent":"$16","viewCount":518,"createTime":"2022-06-24T02:40:08.605Z","updateTime":"2022-07-04T02:23:25.527Z","__v":0,"createdAt":"2022-06-24T02:40:08.605Z","updatedAt":"2023-11-22T11:44:08.573Z"},{"_id":"62b277ed3e9326646e1f6074","title":"Web适配 iPhoneX，就是这么简单","markContent":"$17","viewCount":263,"createTime":"2022-06-22T02:01:17.278Z","updateTime":"2022-06-22T02:01:17.278Z","__v":0,"createdAt":"2022-06-22T02:01:17.278Z","updatedAt":"2023-11-22T12:38:04.861Z"},{"_id":"62abe9c1957f80472322d1cd","title":"Vue TypeScript  使用 Mixins","markContent":"$18","viewCount":292,"createTime":"2022-06-17T02:41:05.050Z","updateTime":"2022-06-17T02:49:16.433Z","__v":0,"createdAt":"2022-06-17T02:41:05.050Z","updatedAt":"2023-11-22T08:09:00.790Z"},{"_id":"62aa9049957f80472322d145","title":"vue 2 typescript 绝对路径配置","markContent":"$19","viewCount":245,"createTime":"2022-06-16T02:07:05.423Z","updateTime":"2022-06-16T02:07:05.423Z","__v":0,"createdAt":"2022-06-16T02:07:05.423Z","updatedAt":"2023-11-22T11:41:31.854Z"},{"_id":"62a93f57957f80472322d0df","title":"vue2 集成 esbuild","markContent":"$1a","viewCount":458,"createTime":"2022-06-15T02:09:27.122Z","updateTime":"2022-06-15T02:09:27.122Z","__v":0,"createdAt":"2022-06-15T02:09:27.122Z","updatedAt":"2023-11-22T11:43:46.227Z"},{"_id":"62a7e9c7957f80472322d084","title":"Vue项目加入TypeScript  js，ts 混合","markContent":"$1b","viewCount":367,"createTime":"2022-06-14T01:52:07.685Z","updateTime":"2022-06-14T01:56:22.440Z","__v":0,"createdAt":"2022-06-14T01:52:07.685Z","updatedAt":"2023-11-22T11:44:30.987Z"},{"_id":"62a6937ca06dc621e3fce438","title":"echarts 渐变色 的使用","markContent":"$1c","viewCount":345,"createTime":"2022-06-13T01:31:40.482Z","updateTime":"2022-06-13T02:03:47.151Z","__v":0,"createdAt":"2022-06-13T01:31:40.482Z","updatedAt":"2023-11-22T11:38:55.112Z"},{"_id":"629867a425f88c33044481c0","title":"Next.js 01 - 创建项目","markContent":"$1d","viewCount":223,"createTime":"2022-06-02T07:32:52.968Z","updateTime":"2022-06-02T07:32:52.968Z","__v":0,"createdAt":"2022-06-02T07:32:52.968Z","updatedAt":"2023-11-22T11:39:17.431Z"},{"_id":"6298679225f88c33044481be","title":"如何将 Node.js Docker 镜像大小减小10倍","markContent":"$1e","viewCount":128,"createTime":"2022-06-02T07:32:34.937Z","updateTime":"2022-06-02T07:32:34.937Z","__v":0,"createdAt":"2022-06-02T07:32:34.937Z","updatedAt":"2023-11-22T11:41:56.088Z"},{"_id":"6298677d25f88c33044481bc","title":"Git分支管理策略","markContent":"$1f","viewCount":436,"createTime":"2022-06-02T07:32:13.009Z","updateTime":"2022-06-02T07:32:13.009Z","__v":0,"createdAt":"2022-06-02T07:32:13.009Z","updatedAt":"2023-11-22T11:39:39.880Z"},{"_id":"6298676425f88c33044481ba","title":"动态生成 uniapp 配置文件 pages.json","markContent":"$20","viewCount":271,"createTime":"2022-06-02T07:31:48.063Z","updateTime":"2022-06-02T07:31:48.063Z","__v":0,"createdAt":"2022-06-02T07:31:48.063Z","updatedAt":"2023-11-22T11:40:27.359Z"},{"_id":"6298674225f88c33044481b8","title":"file转base64, base64 转 blob , blob 转 ArrayBuffer , buffer 转 blob , base64 转 file","markContent":"$21","viewCount":278,"createTime":"2022-06-02T07:31:14.144Z","updateTime":"2022-06-02T07:31:14.144Z","__v":0,"createdAt":"2022-06-02T07:31:14.144Z","updatedAt":"2023-11-22T11:48:32.540Z"},{"_id":"6298672a25f88c33044481b6","title":"vue 2 使用 swiper 插件","markContent":"$22","viewCount":306,"createTime":"2022-06-02T07:30:50.492Z","updateTime":"2022-06-02T07:30:50.492Z","__v":0,"createdAt":"2022-06-02T07:30:50.492Z","updatedAt":"2023-11-22T11:45:26.992Z"},{"_id":"6298671b25f88c33044481b4","title":"Git 设置全局或者当前项目的用户信息","markContent":"$23","viewCount":175,"createTime":"2022-06-02T07:30:35.042Z","updateTime":"2022-06-02T07:30:35.042Z","__v":0,"createdAt":"2022-06-02T07:30:35.042Z","updatedAt":"2023-11-22T11:43:01.926Z"},{"_id":"6298670a25f88c33044481b2","title":"webkit内核浏览器（Chrome, Edge）中自带input样式input:-internal-autofill-selected（修改input背景色）","markContent":"$24","viewCount":310,"createTime":"2022-06-02T07:30:18.035Z","updateTime":"2022-06-02T07:30:18.035Z","__v":0,"createdAt":"2022-06-02T07:30:18.035Z","updatedAt":"2023-11-22T11:46:00.544Z"},{"_id":"629866f525f88c33044481b0","title":"Next.js 添加 Google AdSense 广告","markContent":"$25","viewCount":323,"createTime":"2022-06-02T07:29:57.250Z","updateTime":"2022-06-02T07:29:57.250Z","__v":0,"createdAt":"2022-06-02T07:29:57.250Z","updatedAt":"2023-11-22T12:33:33.661Z"},{"_id":"629866e025f88c33044481ae","title":"Git Clone 指定用户名密码","markContent":"![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eff5ab7f7c349cb945fd235ca909abc~tplv-k3u1fbpfcp-zoom-1.image)\n\n## 目的\n\n使用一行命令进行`clone`一个私人的仓库（`https`），之前未曾设置过任何私钥或者其他相关配置信息\n\n## 原理\n\n在`clone`的`url`上，附带帐号密码验证即可\n\n## 实现\n\n**\n\n```\n$ git clone https://用户:密码@git.coding.net/git/repo.git\n```\n\n## 注意\n\n⚠️ url中的用户不能为邮箱地址（因为邮箱地址中带有`@`特殊符号）\n\n\n作者：NextStack\n链接：https://www.jianshu.com/p/8521601d2a2d\n来源：简书","viewCount":268,"createTime":"2022-06-02T07:29:36.342Z","updateTime":"2022-06-02T07:29:36.342Z","__v":0,"createdAt":"2022-06-02T07:29:36.342Z","updatedAt":"2023-11-22T08:01:06.904Z"},{"_id":"629866cd25f88c33044481ac","title":"vue 2 安装 tailwindcss","markContent":"![](http://developers-center.oss-cn-beijing.aliyuncs.com/undraw_tailwind_css_1egw.svg)\n\n### 1、安装TailwindCSS\n通过 npm 安装 tailwindcss 及其对等依赖项，然后运行 init 命令生成 tailwind.config.js 和 postcss.config.js。\n```\n npm install -D tailwindcss postcss autoprefixer\n npx tailwindcss init -p\n```\n\n### 2、配置您的模板路径\n\n在 tailwind.config.js 文件中添加所有模板文件的路径。\n\n```\nmodule.exports = {\n    content: [\n       \"./index.html\",\n       \"./src/**/*.{vue,js,ts,jsx,tsx}\",\n    ],\n    theme: {\n        extend: {},\n    },\n    plugins: [],\n}\n```\n\n### 3、将 Tailwind 指令添加到您的 CSS\n创建一个 ./src/index.css 文件并为 Tailwind 的每个层添加 @tailwind 指令。\n```\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n\n### 4、导入 CSS 文件\n```\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport './index.css'\n\ncreateApp(App).mount('#app')\n```\n### 5、开始在您的项目中使用 Tailwind\n\n开始使用 Tailwind 的实用程序类来设置您的内容样式。\n```\n<template>\n    <h1 class=\"text-3xl font-bold underline\"> Hello world! </h1>\n</template>\n```\n","viewCount":384,"createTime":"2022-06-02T07:29:17.419Z","updateTime":"2022-06-02T07:29:17.419Z","__v":0,"createdAt":"2022-06-02T07:29:17.419Z","updatedAt":"2023-11-22T11:46:34.169Z"},{"_id":"629866b125f88c33044481aa","title":"React 框架生命周期（类组件与函数组件）","markContent":"$26","viewCount":235,"createTime":"2022-06-02T07:28:49.694Z","updateTime":"2022-06-02T07:28:49.694Z","__v":0,"createdAt":"2022-06-02T07:28:49.694Z","updatedAt":"2023-11-22T13:41:04.924Z"},{"_id":"6298669925f88c33044481a8","title":"vue全局提示插件开发-toast","markContent":"$27","viewCount":235,"createTime":"2022-06-02T07:28:25.063Z","updateTime":"2022-06-02T07:28:25.063Z","__v":0,"createdAt":"2022-06-02T07:28:25.063Z","updatedAt":"2023-11-22T11:40:47.065Z"},{"_id":"6298664525f88c33044481a5","title":"你会用ES6，那倒是用啊！","markContent":"$28","viewCount":290,"createTime":"2022-06-02T07:27:01.133Z","updateTime":"2022-06-02T07:27:01.133Z","__v":0,"createdAt":"2022-06-02T07:27:01.133Z","updatedAt":"2023-11-22T11:57:41.869Z"}]}]
