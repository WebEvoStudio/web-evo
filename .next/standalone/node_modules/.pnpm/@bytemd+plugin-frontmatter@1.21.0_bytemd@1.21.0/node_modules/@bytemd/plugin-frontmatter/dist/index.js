"use strict";
const jsYaml = require("js-yaml");
var formatExports = {};
var format = {
  get exports() {
    return formatExports;
  },
  set exports(v) {
    formatExports = v;
  }
};
(function(module2) {
  (function() {
    var namespace;
    {
      namespace = module2.exports = format2;
    }
    namespace.format = format2;
    namespace.vsprintf = vsprintf;
    if (typeof console !== "undefined" && typeof console.log === "function") {
      namespace.printf = printf;
    }
    function printf() {
      console.log(format2.apply(null, arguments));
    }
    function vsprintf(fmt, replacements) {
      return format2.apply(null, [fmt].concat(replacements));
    }
    function format2(fmt) {
      var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
        return args[argIndex++];
      }, slurpNumber = function() {
        var digits = "";
        while (/\d/.test(fmt[i])) {
          digits += fmt[i++];
          c = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
      };
      for (; i < n; ++i) {
        c = fmt[i];
        if (escaped) {
          escaped = false;
          if (c == ".") {
            leadingZero = false;
            c = fmt[++i];
          } else if (c == "0" && fmt[i + 1] == ".") {
            leadingZero = true;
            i += 2;
            c = fmt[i];
          } else {
            leadingZero = true;
          }
          precision = slurpNumber();
          switch (c) {
            case "b":
              result += parseInt(nextArg(), 10).toString(2);
              break;
            case "c":
              arg = nextArg();
              if (typeof arg === "string" || arg instanceof String)
                result += arg;
              else
                result += String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
              result += parseInt(nextArg(), 10);
              break;
            case "f":
              tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
              result += leadingZero ? tmp : tmp.replace(/^0/, "");
              break;
            case "j":
              result += JSON.stringify(nextArg());
              break;
            case "o":
              result += "0" + parseInt(nextArg(), 10).toString(8);
              break;
            case "s":
              result += nextArg();
              break;
            case "x":
              result += "0x" + parseInt(nextArg(), 10).toString(16);
              break;
            case "X":
              result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
              break;
            default:
              result += c;
              break;
          }
        } else if (c === "%") {
          escaped = true;
        } else {
          result += c;
        }
      }
      return result;
    }
  })();
})(format);
const formatter = formatExports;
const fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format2, ...values) {
    const reason = format2 ? formatter(format2, ...values) : format2;
    return new Constructor(reason);
  }
}
const own = {}.hasOwnProperty;
const markers = {
  yaml: "-",
  toml: "+"
};
function matters(options = "yaml") {
  const results = [];
  let index = -1;
  if (!Array.isArray(options)) {
    options = [options];
  }
  while (++index < options.length) {
    results[index] = matter(options[index]);
  }
  return results;
}
function matter(option) {
  let result = option;
  if (typeof result === "string") {
    if (!own.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = {
      type: result,
      marker: markers[result]
    };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own.call(result, "fence") && !own.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}
function markdownLineEnding(code) {
  return code !== null && code < -2;
}
function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32;
}
function frontmatter$1(options) {
  const settings = matters(options);
  const flow = {};
  let index = -1;
  let matter2;
  let code;
  while (++index < settings.length) {
    matter2 = settings[index];
    code = fence$1(matter2, "open").charCodeAt(0);
    if (code in flow) {
      flow[code].push(parse(matter2));
    } else {
      flow[code] = [parse(matter2)];
    }
  }
  return {
    flow
  };
}
function parse(matter2) {
  const name = matter2.type;
  const anywhere = matter2.anywhere;
  const valueType = name + "Value";
  const fenceType = name + "Fence";
  const sequenceType = fenceType + "Sequence";
  const fenceConstruct = {
    tokenize: tokenizeFence,
    partial: true
  };
  let buffer;
  return {
    tokenize: tokenizeFrontmatter,
    concrete: true
  };
  function tokenizeFrontmatter(effects, ok, nok) {
    const self = this;
    return start;
    function start(code) {
      const position = self.now();
      if (position.column !== 1 || !anywhere && position.line !== 1) {
        return nok(code);
      }
      effects.enter(name);
      buffer = fence$1(matter2, "open");
      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code);
    }
    function afterOpeningFence(code) {
      buffer = fence$1(matter2, "close");
      return lineEnd(code);
    }
    function lineStart(code) {
      if (code === null || markdownLineEnding(code)) {
        return lineEnd(code);
      }
      effects.enter(valueType);
      return lineData(code);
    }
    function lineData(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit(valueType);
        return lineEnd(code);
      }
      effects.consume(code);
      return lineData;
    }
    function lineEnd(code) {
      if (code === null) {
        return nok(code);
      }
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return effects.attempt(fenceConstruct, after, lineStart);
    }
    function after(code) {
      effects.exit(name);
      return ok(code);
    }
  }
  function tokenizeFence(effects, ok, nok) {
    let bufferIndex = 0;
    return start;
    function start(code) {
      if (code === buffer.charCodeAt(bufferIndex)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return insideSequence(code);
      }
      return nok(code);
    }
    function insideSequence(code) {
      if (bufferIndex === buffer.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code)) {
          effects.enter("whitespace");
          return insideWhitespace(code);
        }
        return fenceEnd(code);
      }
      if (code === buffer.charCodeAt(bufferIndex++)) {
        effects.consume(code);
        return insideSequence;
      }
      return nok(code);
    }
    function insideWhitespace(code) {
      if (markdownSpace(code)) {
        effects.consume(code);
        return insideWhitespace;
      }
      effects.exit("whitespace");
      return fenceEnd(code);
    }
    function fenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit(fenceType);
        return ok(code);
      }
      return nok(code);
    }
  }
}
function fence$1(matter2, prop) {
  return matter2.marker ? pick$1(matter2.marker, prop).repeat(3) : pick$1(matter2.fence, prop);
}
function pick$1(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}
function frontmatterFromMarkdown(options) {
  const settings = matters(options);
  const enter = {};
  const exit = {};
  let index = -1;
  while (++index < settings.length) {
    const matter2 = settings[index];
    enter[matter2.type] = opener(matter2);
    exit[matter2.type] = close;
    exit[matter2.type + "Value"] = value;
  }
  return { enter, exit };
}
function opener(matter2) {
  return open;
  function open(token) {
    this.enter({ type: matter2.type, value: "" }, token);
    this.buffer();
  }
}
function close(token) {
  const data = this.resume();
  this.exit(token).value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function frontmatterToMarkdown(options) {
  const unsafe = [];
  const handlers = {};
  const settings = matters(options);
  let index = -1;
  while (++index < settings.length) {
    const matter2 = settings[index];
    handlers[matter2.type] = handler(matter2);
    unsafe.push({ atBreak: true, character: fence(matter2, "open").charAt(0) });
  }
  return { unsafe, handlers };
}
function handler(matter2) {
  const open = fence(matter2, "open");
  const close2 = fence(matter2, "close");
  return handle;
  function handle(node) {
    return open + (node.value ? "\n" + node.value : "") + "\n" + close2;
  }
}
function fence(matter2, prop) {
  return matter2.marker ? pick(matter2.marker, prop).repeat(3) : (
    // @ts-expect-error: Theyâ€™re mutually exclusive.
    pick(matter2.fence, prop)
  );
}
function pick(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}
function remarkFrontmatter(options = "yaml") {
  const data = this.data();
  add("micromarkExtensions", frontmatter$1(options));
  add("fromMarkdownExtensions", frontmatterFromMarkdown(options));
  add("toMarkdownExtensions", frontmatterToMarkdown(options));
  function add(field, value2) {
    const list = (
      /** @type {unknown[]} */
      // Other extensions
      /* c8 ignore next 2 */
      data[field] ? data[field] : data[field] = []
    );
    list.push(value2);
  }
}
function frontmatter({
  onError
} = {}) {
  return {
    remark: (processor) => (
      // @ts-ignore
      processor.use(remarkFrontmatter).use(() => (tree, file) => {
        const fisrtNode = tree.children[0];
        if ((fisrtNode == null ? void 0 : fisrtNode.type) !== "yaml")
          return;
        try {
          file.frontmatter = jsYaml.load(fisrtNode.value);
        } catch (err) {
          onError == null ? void 0 : onError(err);
        }
      })
    )
  };
}
module.exports = frontmatter;
