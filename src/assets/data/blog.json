[
  {"id": "1","title":"你会用ES6，那倒是用啊！","mark_content":"不是标题党，这是一位leader在一次代码评审会对小组成员发出的“怒吼”，原因是在代码评审中发现很多地方还是采用ES5的写法，也不是说用ES5写法不行，会有BUG，只是造成代码量增多，可读性变差而已。\n\n恰好，这位leader有代码洁癖，面对3~5年经验的成员，还写这种水平的代码，极为不满，不断对代码进行吐槽。不过对于他的吐槽，我感觉还是有很大收获的，故就把leader的吐槽记录下来，分享给掘友们，觉得有收获点个赞，有错误的或者更好的写法，非常欢迎在评论中留言。\n\n**ps：ES5之后的JS语法统称ES6！！！**\n\n## 一、关于取值的吐槽\n\n取值在程序中非常常见，比如从对象`obj`中取值。\n\n```\nconst obj = {\n    a:1,\n    b:2,\n    c:3,\n    d:4,\n    e:5,\n}\n```\n\n**吐槽**：\n\n```\nconst a = obj.a;\nconst b = obj.b;\nconst c = obj.c;\nconst d = obj.d;\nconst e = obj.e;\n```\n\n或者\n\n```\nconst f = obj.a + obj.d;\nconst g = obj.c + obj.e;\n```\n\n吐槽：“不会用ES6的解构赋值来取值吗？5行代码用1行代码搞定不香吗？直接用对象名加属性名去取值，要是对象名短还好，很长呢？搞得代码中到处都是这个对象名。”\n\n**改进**：\n\n```\nconst {a,b,c,d,e} = obj;\nconst f = a + d;\nconst g = c + e;\n```\n\n**反驳**\n\n不是不用ES6的解构赋值，而是服务端返回的数据对象中的属性名不是我想要的，这样取值，不是还得重新创建个遍历赋值。\n\n**吐槽**\n\n看来你对ES6的解构赋值掌握的还是不够彻底。如果想创建的变量名和对象的属性名不一致，可以这么写：\n\n```\nconst {a:a1} = obj;\nconsole.log(a1);// 1\n```\n\n**补充**\n\nES6的解构赋值虽然好用。但是要注意解构的对象不能为`undefined`、`null`。否则会报错，故要给被解构的对象一个默认值。\n\n```\nconst {a,b,c,d,e} = obj || {};\n```\n\n## 二、关于合并数据的吐槽\n\n比如合并两个数组，合并两个对象。\n\n```\nconst a = [1,2,3];\nconst b = [1,5,6];\nconst c = a.concat(b);//[1,2,3,1,5,6]\n\nconst obj1 = {\n  a:1,\n}\nconst obj2 = {\n  b:1,\n}\nconst obj = Object.assign({}, obj1, obj2);//{a:1,b:1}\n```\n\n**吐槽**\n\nES6的扩展运算符是不是忘记了，还有数组的合并不考虑去重吗？\n\n**改进**\n\n```\nconst a = [1,2,3];\nconst b = [1,5,6];\nconst c = [...new Set([...a,...b])];//[1,2,3,5,6]\n\nconst obj1 = {\n  a:1,\n}\nconst obj2 = {\n  b:1,\n}\nconst obj = {...obj1,...obj2};//{a:1,b:1}\n```\n\n## 三、关于拼接字符串的吐槽\n\n```\nconst name = '小明';\nconst score = 59;\nlet result = '';\nif(score > 60){\n  result = `${name}的考试成绩及格`; \n}else{\n  result = `${name}的考试成绩不及格`; \n}\n```\n\n**吐槽**\n\n像你们这样用ES6字符串模板，还不如不用，你们根本不清楚在`${}`中可以做什么操作。在`${}`中可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。\n\n**改进**\n\n```\nconst name = '小明';\nconst score = 59;\nconst result = `${name}${score > 60?'的考试成绩及格':'的考试成绩不及格'}`;\n```\n\n## 四、关于if中判断条件的吐槽\n\n```\nif(\n    type == 1 ||\n    type == 2 ||\n    type == 3 ||\n    type == 4 ||\n){\n   //...\n}\n```\n\n**吐槽**\n\nES6中数组实例方法`includes`会不会使用呢？\n\n**改进**\n\n```\nconst condition = [1,2,3,4];\n\nif( condition.includes(type) ){\n   //...\n}\n```\n\n## 五、关于列表搜索的吐槽\n\n在项目中，一些没分页的列表的搜索功能由前端来实现，搜索一般分为精确搜索和模糊搜索。搜索也要叫过滤，一般用`filter`来实现。\n\n```\nconst a = [1,2,3,4,5];\nconst result = a.filter( \n  item =>{\n    return item === 3\n  }\n)\n```\n\n**吐槽**\n\n如果是精确搜索不会用ES6中的`find`吗？性能优化懂么，`find`方法中找到符合条件的项，就不会继续遍历数组。\n\n**改进**\n\n```\nconst a = [1,2,3,4,5];\nconst result = a.find( \n  item =>{\n    return item === 3\n  }\n)\n```\n\n## 六、关于扁平化数组的吐槽\n\n一个部门JSON数据中，属性名是部门id，属性值是个部门成员id数组集合，现在要把有部门的成员id都提取到一个数组集合中。\n\n```\nconst deps = {\n'采购部':[1,2,3],\n'人事部':[5,8,12],\n'行政部':[5,14,79],\n'运输部':[3,64,105],\n}\nlet member = [];\nfor (let item in deps){\n    const value = deps[item];\n    if(Array.isArray(value)){\n        member = [...member,...value]\n    }\n}\nmember = [...new Set(member)]\n```\n\n**吐槽**\n\n获取对象的全部属性值还要遍历吗？`Object.values`忘记了吗？还有涉及到数组的扁平化处理，为啥不用ES6提供的`flat`方法呢，还好这次的数组的深度最多只到2维，还要是遇到4维、5维深度的数组，是不是得循环嵌套循环来扁平化？\n\n**改进**\n\n```\nconst deps = {\n    '采购部':[1,2,3],\n    '人事部':[5,8,12],\n    '行政部':[5,14,79],\n    '运输部':[3,64,105],\n}\nlet member = Object.values(deps).flat(Infinity);\n```\n\n其中使用`Infinity`作为`flat`的参数，使得无需知道被扁平化的数组的维度。\n\n**补充**\n\n`flat`方法不支持IE浏览器。\n\n## 七、关于获取对象属性值的吐槽\n\n```\nconst name = obj && obj.name;\n```\n\n**吐槽**\n\nES6中的可选链操作符会使用么？\n\n**改进**\n\n```\nconst name = obj?.name;\n```\n\n## 八、关于添加对象属性的吐槽\n\n当给对象添加属性时，如果属性名是动态变化的，该怎么处理。\n\n```\nlet obj = {};\nlet index = 1;\nlet key = `topic${index}`;\nobj[key] = '话题内容';\n```\n\n**吐槽**\n\n为何要额外创建一个变量。不知道ES6中的对象属性名是可以用表达式吗？\n\n**改进**\n\n```\nlet obj = {};\nlet index = 1;\nobj[`topic${index}`] = '话题内容';\n```\n\n## 九、关于输入框非空的判断\n\n在处理输入框相关业务时，往往会判断输入框未输入值的场景。\n\n```\nif(value !== null && value !== undefined && value !== ''){\n    //...\n}\n```\n\n**吐槽**\n\nES6中新出的空值合并运算符了解过吗，要写那么多条件吗？\n\n```\nif((value??'') !== ''){\n  //...\n}\n```\n\n## 十、关于异步函数的吐槽\n\n异步函数很常见，经常是用 Promise 来实现。\n\n```\nconst fn1 = () =>{\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(1);\n    }, 300);\n  });\n}\nconst fn2 = () =>{\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(2);\n    }, 600);\n  });\n}\nconst fn = () =>{\n   fn1().then(res1 =>{\n      console.log(res1);// 1\n      fn2().then(res2 =>{\n        console.log(res2)\n      })\n   })\n}\n```\n\n**吐槽**\n\n如果这样调用异步函数，不怕形成地狱回调啊！\n\n**改进**\n\n```\nconst fn = async () =>{\n  const res1 = await fn1();\n  const res2 = await fn2();\n  console.log(res1);// 1\n  console.log(res2);// 2\n}\n```\n\n**补充**\n\n但是要做并发请求时，还是要用到`Promise.all()`。\n\n```\nconst fn = () =>{\n   Promise.all([fn1(),fn2()]).then(res =>{\n       console.log(res);// [1,2]\n   }) \n}\n```\n\n如果并发请求时，只要其中一个异步函数处理完成，就返回结果，要用到`Promise.race()`。\n\n## 十一、后续\n\n欢迎来对以上十点leader的吐槽进行反驳，你的反驳如果有道理的，下次代码评审会上，我替你反驳。\n\n此外以上的整理内容有误的地方，欢迎在评论中指正，万分感谢。\n\n如果你还有其它想吐槽的，也非常欢迎在评论中留下你的吐槽。\n\n读完有帮助，不妨关注一下，点个赞支持一下。\n\n作者：红尘炼心\\\n链接：https://juejin.cn/post/7016520448204603423\\\n来源：稀土掘金"},
  {
    "id": "2",
    "title": "vue全局提示插件开发-toast",
    "mark_content":"**前言**\n\n在没有封装插件之前，如果不使用第三方插件，那么很多情况下我们会编写几个常用的组件来提供给页面使用，如Alert/Loading组件，而你可能需要在很多页面中引入并且通过components注册组件，但是像这样使用率很高的组件一般我们希望全局注册后直接就可以在相应页面使用，因此我们需要将他们封装成插件，这里我们编写一个toast全局提示插件来作个简单的介绍\n\n**插件**\n\n```\n插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：\n\n1.添加全局方法或者 property。\n\n2.添加全局资源：指令/过滤器/过渡等。\n\n3.通过全局混入来添加一些组件选项。\n\n4.添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n\n5.一个库，提供自己的 API，同时提供上面提到的一个或多个功能。\n```\n\nvue插件的编写方法一般分为以上5类，其注册与绑定机制如下：\n\n```\nexport default {\n    install(Vue, options) {\n        Vue.myGlobalMethod = function () {  // 1. 添加全局方法或属性，如:  vue-custom-element\n            // 逻辑...\n        }\n        Vue.directive('my-directive', {  // 2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch\n            bind (el, binding, vnode, oldVnode) {\n                // 逻辑...\n            }\n            ...\n        })\n        Vue.mixin({\n            created: function () {  // 3. 通过全局 mixin方法添加一些组件选项，如: vuex\n                // 逻辑...\n            }\n            ...\n        })\n        Vue.prototype.$myMethod = function (options) {  // 4. 添加实例方法，通过把它们添加到 Vue.prototype 上实现\n            // 逻辑...\n        }\n    }\n}\n```\n\n\\\n上方代码使用了es6部分语法列出了4种编写插件的方法，而install是注册插件主要调用的方法，包含了两个参数（Vue实例和自定义配置属性options）\n\n**开发插件**\n\n我们这里主要使用的是第四种方法，将我们的插件函数注册到Vue.prototype实例上面\\\n首先我们在plugin里创建个toast文件夹用来放置插件,里面包含两个文件，toast.vue和toast.js，\n\n\\\n\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3762e7487fa745d5a732f5e9697196ee~tplv-k3u1fbpfcp-zoom-1.image)\n\n\\\n\n\n然后在编写我们的样式结构文件toast.vue\n\n这里我们使用了一个visible变量来控制提示框的显示，message为提示的消息\n\n```\n<template>\n      <div v-if=\"visible\">\n          <div>{{message}}</div>\n      </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      visible: false,\n      message: \"\"\n    };\n  }\n};\n</script>\n```\n\n\\\n接着在toast.js里面编写插件的方法与处理函数\n\n```\nimport ToastComponent from './toast.vue'    //引入toast.vue组件\n\nexport default {    // 导出一个对象，里面包含vue注册插件所调用的方法install\n    install: function (Vue) {\n        const ToastConstructor = Vue.extend(ToastComponent)    // 将toast.vue组件生成为Vue的子类\n        const instance = new ToastConstructor();    // 生成一个该子类的实例\n\n        instance.$mount(document.createElement('div'))    // 将这个实例挂载在新创建的div上，并加入到body中\n        document.body.appendChild(instance.$el)\n\n        // 通过Vue的原型注册一个方法$toast，有两个参数（msg为提示的文字，duration为延时关闭）\n        Vue.prototype.$toast = (msg, duration = 1500) => {\n            if (instance.visible) return;    // visible是toast.vue组件的一个变量，用来控制提示框的显示\n\n            instance.message = msg;\n            instance.visible = true;\n\n            setTimeout(() => {    // 默认延时1.5s关闭提示框\n                instance.visible = false;\n            }, duration);\n        }\n    }\n}\n```\n\n\\\n这样我们就完成了组件的封装，是不是很简单\n\n**使用插件**\n\n现在把我们封装好的插件引入到main.js中\n\n```\nimport toast from './plugin/toast'\nVue.use(toast);\n```\n\n\\\n然后我们就可以在组件中使用它了\n\n```\nthis.$toast('提示文字')\n```\n\n我们现在把toast.vue添加上样式和过度效果，让它看起来更加的友好，以下是toast.vue文件的全部内容\n\n```\n<template>\n   <!-- 全局提示框 -->\n   <transition name=\"slide-fade\">\n      <div v-if=\"visible\" class=\"dialog-tips\">\n          <div>{{message}}</div>\n      </div>\n  </transition>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      visible: false,\n      message: \"\"\n    };\n  }\n};\n</script>\n<style scoped>\n.dialog-tips{\n    min-width: 380px;\n    box-sizing: border-box;\n    border-radius: 4px;\n    border: 1px solid #e1f3d8;\n    position: fixed;\n    left: 50%;\n    top: 20px;\n    transform: translateX(-50%);\n    background-color: #f0f9eb;\n    overflow: hidden;\n    padding: 15px 15px 15px 20px;\n    display: flex;\n    align-items: center;\n    color: #67c23a;\n}\n\n.slide-fade-enter, .slide-fade-leave-to {\n  margin-top:-30px;\n  opacity: 0;\n\n}\n\n.slide-fade-enter-active,.slide-fade-leave-active {\n  transition: all .3s ease;\n}\n\n.slide-fade-enter-to,.slide-fade-leave {\n  margin-top:0px;\n  opacity:1;\n}\n</style>\n```\n\n\\\n让我们来看看效果\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6174dcccd564c12ac1a757c04726898~tplv-k3u1fbpfcp-zoom-1.image)\n\n\\\n\n\n**结语**\n\n以上我们就实现了一个简单的toast插件，开发插件的方式和插件的类型有很多种，这里只是介绍了其中的一种方式，帮助大家了解在编写插件的过程中所用到的方法，大家也可以使用其它方法来去开发不同类型的插件。"
  }
]
